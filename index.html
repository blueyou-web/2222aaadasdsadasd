<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Í≤åÏûÑ Î≥¥Îìú (Firebase Ïó∞Îèô)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- YouTube IFrame Player API Î°úÎìú -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto-Sans-KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #1c1c1b;
            --bg-secondary: #1c1c1b;
            --bg-tertiary: #374151;
            --bg-board: rgba(36, 36, 36, 0.5);
            --border-primary: #D4B783;
            --border-secondary: #4b5563;
            --text-primary: #EAEAEA;
            --text-secondary: #B0B0C0;
            --text-tertiary: #888899;
            --accent-primary: #D4B783;
            --accent-secondary: #C1A26C;
            --modal-backdrop: rgba(0, 0, 0, 0.8);
            --log-move: #60A5FA;
            --log-damage: #F87171;
            --log-heal: #4ADE80; 
            --log-system: #FBBF24;
            --log-join: #4ADE80;
            --log-admin: #9333ea;
            --turn-highlight-color: #FBBF24;
            --bg-game-id: #1f2937;
            --bg-selection-overlay: linear-gradient(180deg, var(--bg-primary) 0%, rgba(36, 36, 36, 0.7) 100%);
            --mp-color: #3B82F6;
            
            /* Custom Scrollbar Colors (Dark Mode) */
            --scrollbar-thumb: var(--accent-primary);
            --scrollbar-track: #2d2d2d;

            /* Skill Button Glow/Ring Color */
            --skill-ring-color: rgba(212, 183, 131, 0.8);

            /* Turn Box Style */
            --turn-box-bg: rgba(55, 65, 81, 0.5); /* Semi-transparent tertiary bg */
            --turn-box-border: var(--accent-primary);
            --summary-box-bg: rgba(212, 183, 131, 0.1);

            /* NEW: Gradients for numbers */
            --gradient-start: #ffffff; 
            --gradient-end: var(--accent-primary);
            --pc-color: #4ADE80;
            --enemy-color: #F87171;
        }

        html.light {
            --bg-primary: #FDFBF6;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #E5E7EB;
            --bg-board: rgba(229, 231, 235, 0.8);
            --border-primary: #8C6A48;
            --border-secondary: #D1D5DB;
            --text-primary: #3A3226;
            --text-secondary: #574B3A;
            --text-tertiary: #6B7280;
            --accent-primary: #8C6A48;
            --accent-secondary: #A98A66;
            --turn-highlight-color: #D97706;
            --log-admin: #6D28D9;
            --bg-game-id: #E5E7EB;
            --bg-selection-overlay: linear-gradient(180deg, var(--bg-primary) 0%, rgba(229, 231, 235, 0.7) 100%);
            --mp-color: #1D4ED8;

            /* Custom Scrollbar Colors (Light Mode) */
            --scrollbar-thumb: var(--accent-primary);
            --scrollbar-track: #F0F0F0;

            /* Skill Button Glow/Ring Color */
            --skill-ring-color: rgba(140, 106, 72, 0.8);

            /* Turn Box Style */
            --turn-box-bg: rgba(229, 231, 235, 0.5); /* Semi-transparent tertiary bg */
            --turn-box-border: var(--accent-primary);
            --summary-box-bg: rgba(140, 106, 72, 0.1);

            /* NEW: Gradients for numbers (Light Mode adjustment) */
            --gradient-start: #3A3226; 
            --gradient-end: #000000;
            --pc-color: #16A34A;
            --enemy-color: #DC2626;
        }

        /* Global Custom Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px; /* For horizontal scrollbars */
        }
        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 10px;
            opacity: 0.7; /* Make slightly translucent */
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }
        
        /* Custom horizontal scrollbar for selection list (more transparent) */
        #selection-list::-webkit-scrollbar {
            height: 6px;
        }
        #selection-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        html.light #selection-list::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        
        body, h1, h2, h3, h4, button, .font-title {
            font-family: 'Cinzel', 'Noto Sans KR', serif;
            letter-spacing: 0.5px;
        }
        
        body {
            padding-top: 250px; 
        }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(10, minmax(0, 1fr));
            grid-template-rows: repeat(10, minmax(0, 1fr));
            width: 100%;
            aspect-ratio: 1 / 1;
            max-width: 90vw;
            max-height: 90vh;
            background-color: var(--bg-board);
            border: 1px solid var(--border-secondary);
        }
        .cell {
            border: 1px solid var(--border-secondary);
            position: relative;
            transition: background-color 0.2s;
        }

        .cell:hover {
            background-color: rgba(212, 183, 131, 0.1);
        }
        
        /* NEW: Obstacle and Damage Tiles Styles */
        .cell.tile-obstacle {
            background-color: #4B5563; /* Dark gray */
            background-image: repeating-linear-gradient(45deg, rgba(0,0,0,.1) 0, rgba(0,0,0,.1) 2px, transparent 0, transparent 5px);
            cursor: not-allowed;
        }
        .cell.tile-damage {
            background-color: #991B1B; /* Dark red */
            box-shadow: inset 0 0 10px rgba(248, 100, 100, 0.5);
            cursor: help;
        }
        .cell.tile-damage:hover {
            background-color: #EF4444;
        }

        .combat-range {
            outline: 2px solid transparent;
            outline-offset: -2px;
            transition: outline 0.2s, background-color 0.2s, box-shadow 0.2s;
            box-shadow: inset 0 0 12px;
        }

        .attack-range-move {
            background-color: rgba(212, 183, 131, 0.05);
            outline-color: var(--accent-primary);
            box-shadow: inset 0 0 12px var(--accent-primary);
        }

        .attack-range-skill {
            background-color: rgba(239, 68, 68, 0.05);
            outline-color: var(--log-damage);
            box-shadow: inset 0 0 12px var(--log-damage);
        }
        
        .heal-range-skill {
            background-color: rgba(74, 222, 128, 0.08);
            outline-color: var(--log-heal);
            box-shadow: inset 0 0 12px var(--log-heal);
        }

        .enemy-threat-range {
            background-color: rgba(200, 50, 50, 0.07);
        }

        .character-token {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s, filter 0.3s;
            position: absolute; 
            z-index: 20;
            top: 0;
            left: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid transparent;
        }
        
        .character-token.enemy-token {
            border-color: #ef4444;
        }

        /* Damage Effect */
        .character-token.show-hit-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.4);
            box-shadow: inset 0 0 10px rgba(255, 0, 0, 0.6);
            pointer-events: none;
        }

        @keyframes hit-effect {
            0%, 100% { transform: translate(0, 0) rotate(0); }
            20% { transform: translate(-3px, 0) rotate(-2deg); }
            40% { transform: translate(3px, 0) rotate(2deg); }
            60% { transform: translate(-3px, 0) rotate(-2deg); }
            80% { transform: translate(3px, 0) rotate(2deg); }
            50% { filter: brightness(1.7) drop-shadow(0 0 5px #ef4444); }
        }

        .hit-animation {
            animation: hit-effect 0.5s ease-in-out;
        }
        
        /* Heal Effect */
        .character-token.show-heal-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.4); 
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.6);
            pointer-events: none;
        }

        @keyframes heal-effect {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.5) drop-shadow(0 0 5px #4ADE80); }
        }

        .heal-animation {
            animation: heal-effect 0.5s ease-in-out;
        }

        /* Turn Marker Animation */
        @keyframes bounce-arrow {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        .turn-marker {
            /* Now also acts as the skip move button */
            position: absolute;
            top: -2.5rem; 
            left: 50%;
            transform: translateX(-50%);
            color: var(--turn-highlight-color);
            font-size: 2rem;
            line-height: 1;
            animation: bounce-arrow 1s infinite ease-in-out;
            z-index: 30;
            filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.7));
            cursor: pointer; /* Make it clickable for skipping move */
        }
        
        /* HP/MP Bar styles */
        .hp-mp-bar-container {
             position: absolute;
             bottom: 0;
             left: 0;
             width: 100%;
             z-index: 5;
             display: flex;
             flex-direction: column;
             gap: 1px; /* Space between bars */
             padding: 1px 0; /* Vertical padding */
        }
        .hp-bar {
            height: 3px;
            background-color: #3b0707;
            overflow: hidden;
            width: 90%;
            margin: 0 auto;
            border-radius: 1px;
        }
        .mp-bar {
            height: 2px; /* Smaller MP bar */
            background-color: #111827;
            overflow: hidden;
            width: 90%;
            margin: 0 auto;
            border-radius: 1px;
        }
        .hp-fill { background-color: #EF4444; height: 100%; transition: width 0.3s; }
        .mp-fill { background-color: var(--mp-color); height: 100%; transition: width 0.3s; }

        html:not(.light) .character-token:not(.enemy-token) {
            box-shadow: 0 0 8px rgba(212, 183, 131, 0.4), 0 0 10px rgba(0,0,0,0.5);
        }
        .token-placeholder {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-primary);
        }
        .character-token:hover {
            transform: scale(1.1);
        }
        .selected-character {
             box-shadow: 0 0 15px 3px var(--accent-primary);
             border-color: var(--accent-primary) !important;
        }
        
        .form-input {
             background-color: var(--bg-tertiary);
             border: 1px solid var(--border-secondary);
             color: var(--text-primary);
             border-radius: 4px;
             padding: 0.5rem 0.75rem;
             width: 100%;
             transition: all 0.2s;
        }
        .form-input:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 5px rgba(212, 183, 131, 0.5);
            outline: none;
            background-color: var(--bg-tertiary);
        }

        .panel {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            position: relative;
            box-shadow: 0 0 15px rgba(0,0,0, 0.2);
            border-image: linear-gradient(to bottom right, var(--accent-secondary), transparent) 1;
        }
        
        .modal-content {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            box-shadow: 0 0 25px rgba(212, 183, 131, 0.2);
        }
        .modal-backdrop {
            background-color: var(--modal-backdrop);
            backdrop-filter: blur(2px);
        }

        #character-selection-overlay {
            height: 250px; 
            background: var(--bg-selection-overlay);
            backdrop-filter: blur(4px);
            z-index: 40;
            border-bottom: 1px solid var(--border-secondary);
            transition: height 0.3s ease-in-out, background-color 0.3s;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
        }
        
        #character-selection-overlay.collapsed { height: 1rem; }
        /* NEW: Improved horizontal scrolling for selection list */
        #selection-list { 
            overflow-x: scroll; 
            white-space: nowrap; 
            -webkit-overflow-scrolling: touch; 
            justify-content: flex-start; /* Align cards to the start for better horizontal flow */
        }
        #selection-list::-webkit-scrollbar {
            height: 6px;
        }
        #selection-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        html.light #selection-list::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }

        .char-card-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 150px; 
            height: 200px; 
            min-width: 150px; 
            border-radius: 16px;
            overflow: hidden;
            position: relative;
            background-size: cover;
            background-position: center top; 
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s;
            border: 1px solid var(--border-secondary);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        .card-placeholder { font-size: 4rem; color: var(--accent-primary); opacity: 0.5; }
        .char-card-item:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(212, 183, 131, 0.2); border-color: var(--accent-primary); }
        .char-card-item.selected { border-color: var(--accent-primary); transform: scale(1.05); box-shadow: 0 0 25px var(--accent-primary); }
        .char-card-item:not([draggable="true"]) { cursor: default; }
        .char-card-item[draggable="true"] { cursor: grab; }

        .char-card-item.enemy-card { border-color: #7f1d1d; }
        .char-card-item.enemy-card:hover { border-color: #ef4444; box-shadow: 0 10px 20px rgba(239, 68, 68, 0.2); }
        .char-card-item.enemy-card.selected { border-color: #ef4444; box-shadow: 0 0 25px #ef4444; }

        .char-card-item .char-card-info { background: linear-gradient(0deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.0) 60%); }
        html.light .char-card-item .char-card-info { 
             background: linear-gradient(0deg, rgba(200, 200, 200, 0.9) 0%, rgba(255, 255, 255, 0.0) 60%); 
             color: var(--text-primary);
        }
        html.light .char-card-item.enemy-card .char-card-info { 
             background: linear-gradient(0deg, rgba(255, 200, 200, 0.9) 0%, rgba(255, 255, 255, 0.0) 60%);
             color: var(--text-primary);
        }

        .enemy-card .details-btn { border-color: #991b1b; color: #f87171; }
        .enemy-card .details-btn:hover { border-color: #ef4444; color: #ef4444; }


        .char-card-info {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px; 
            height: 100%; 
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            color: var(--text-primary);
        }

        .turn-highlight {
            border: 1px solid #fBBF24;
            background-color: rgba(251, 191, 36, 0.05);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.2);
        }
        
        button { letter-spacing: 1px; border-radius: 2px; transition: all 0.2s ease; border: 1px solid var(--border-secondary); }
        button:hover { border-color: var(--accent-primary); color: var(--accent-primary); background-color: rgba(212, 183, 131, 0.1) !important; box-shadow: 0 0 10px rgba(212, 183, 131, 0.3); }
        button.bg-green-600 { background-color: var(--accent-primary) !important; color: var(--bg-primary) !important; font-weight: bold; border: none; }
        button.bg-red-600 { background-color: var(--log-damage) !important; color: var(--text-primary) !important; font-weight: bold; border: none; }
        
        #admin-panel-btn { background-color: var(--accent-primary); color: var(--bg-primary) !important; }

        .details-btn { background: transparent; border: 1px solid var(--accent-secondary); color: var(--accent-secondary); padding: 2px 8px; font-size: 0.75rem; border-radius: 2px; }

        #game-log-list li { background-color: transparent; padding: 4px 0; border: none; position: relative; padding-left: 1.75rem; line-height: 1.5; font-size: 0.8rem; font-family: 'Noto Sans KR', sans-serif; }
        #game-log-list li::before { content: '‚Ä¢'; position: absolute; left: 0.5rem; top: 4px; font-weight: bold; color: var(--accent-primary); }
        #game-log-list .log-move::before { color: var(--log-move); }
        #game-log-list .log-damage::before { color: var(--log-damage); }
        #game-log-list .log-heal::before { color: var(--log-heal); }
        #game-log-list .log-system::before { color: var(--log-system); }
        #game-log-list .log-join::before { color: var(--log-join); }
        #game-log-list .log-admin-move::before { color: var(--log-admin); }

        .profile-modal-container { 
            background: url('https://www.transparenttextures.com/patterns/dark-matter.png'), linear-gradient(to bottom right, #1a1a1a, #111111); 
            color: var(--text-primary); 
            border: 1px solid var(--accent-primary); 
            box-shadow: 0 0 30px rgba(212, 183, 131, 0.3); 
            display: grid; 
            grid-template-columns: 350px 1fr;
            width: 100%; 
            max-width: 900px; 
            /* height: 600px; Remove fixed height */
            max-height: 90vh; /* Set max height relative to viewport */
            overflow: hidden; 
            position: relative; 
        }
        .profile-modal-container.enemy-profile { border-color: #ef4444; box-shadow: 0 0 30px rgba(239, 68, 68, 0.3); }
        .profile-modal-container.enemy-profile .profile-char-name, 
        .profile-modal-container.enemy-profile .stat-item svg, 
        .profile-modal-container.enemy-profile h3 { color: #f87171; }
        .profile-modal-container.enemy-profile #edit-char-btn { background-color: #991b1b; }
        .profile-modal-container.enemy-profile #edit-char-btn:hover { background-color: #ef4444 !important; }

        .profile-char-image { 
            width: 100%; 
            height: 100%; 
            background-size: cover; 
            background-position: center 20%; 
        }
        .profile-stats-panel { 
            padding: 2.5rem;
            background-color: rgba(0,0,0,0.1); 
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        .profile-char-name { font-size: 2.5rem; font-weight: bold; color: var(--accent-primary); margin-bottom: 0.5rem; }
        .profile-char-type { font-size: 1rem; color: var(--text-secondary); margin-bottom: 2rem; flex-shrink: 0; }
        .profile-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; flex-shrink: 0; }
        .stat-item { display: flex; align-items: center; gap: 0.75rem; }
        .stat-item svg { width: 24px; height: 24px; color: var(--accent-secondary); }
        .stat-item .value { font-size: 1.25rem; font-weight: bold; }
        .stat-item .label { font-size: 0.8rem; color: var(--text-tertiary); }
        
        .profile-content-scroll {
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 1rem;
            margin-right: -1rem;
        }
        /* Make sure scrollbars are themed */
        .profile-content-scroll::-webkit-scrollbar { width: 8px; }
        .profile-content-scroll::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        .profile-content-scroll::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
        .profile-content-scroll::-webkit-scrollbar-thumb:hover { background: var(--accent-secondary); }

        #profile-modal #close-modal-btn { position: absolute; top: 1rem; right: 1rem; z-index: 10; background: none; border: none; }
        
        /* NEW: Fix for Edit Modal content overflow */
        .profile-modal-container[style*="grid-template-columns: 1fr"] {
             height: auto; /* Allow height to shrink/grow */
             min-height: 400px;
        }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .p-6 {
            display: flex;
            flex-direction: column;
            height: 100%; /* Ensure content panel takes full height */
        }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4 {
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 1rem; /* Adjust padding for scrollbar */
            margin-right: -1rem;
        }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar { width: 8px; }
        /* Apply themed scrollbars to edit modal */
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar-thumb:hover { background: var(--accent-secondary); }


        /* User Info Button Style */
        .info-button {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .info-button:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        
        /* NEW: Skill Button Pill Shape and Glow */
        .skill-btn {
            border-radius: 9999px; /* Pill shape */
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-secondary);
            transition: all 0.3s ease;
        }
        
        .skill-btn:not([disabled]):hover {
            box-shadow: 0 0 10px var(--skill-ring-color), 0 0 5px var(--accent-primary) inset;
        }

        .skill-btn.ring-2 {
             box-shadow: 0 0 10px var(--skill-ring-color) !important;
        }

        /* NEW: Horizontal button group for utility controls */
        #utility-controls {
            position: fixed;
            bottom: 8px;
            right: 8px;
            z-index: 50;
            display: flex;
            gap: 8px; /* Spacing between buttons */
            align-items: flex-end;
        }

        /* NEW: Stylish Turn Box */
        #turn-status.stylish-turn-box {
            /* Background: Darker gradient of accent color */
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.1));
            backdrop-filter: blur(2px);
            border: 2px solid var(--accent-primary);
            box-shadow: 0 0 15px rgba(212, 183, 131, 0.3); /* Lighter glow for the box */
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
        }
        html.light #turn-status.stylish-turn-box {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.1));
            box-shadow: 0 0 15px rgba(140, 106, 72, 0.2);
        }

        #turn-status.stylish-turn-box p {
            /* Set 'ÌòÑÏû¨ ÌÑ¥:' text color to primary accent (scrollbar thumb color) */
             color: var(--accent-primary) !important; 
             font-weight: bold;
        }

        #turn-status.stylish-turn-box #current-turn-char {
             color: var(--accent-primary); /* Use accent primary for the name highlight */
        }
        
        /* UPDATED: Stylish Unit Summary Box - Removed background/borders for transparent look */
        #unit-summary {
             /* background-color: var(--summary-box-bg); REMOVED */
             /* border: 1px solid var(--border-secondary); REMOVED */
             border-radius: 8px;
             padding: 0.75rem 0; /* Reduced vertical padding slightly */
             display: grid;
             grid-template-columns: 1fr 1fr;
             gap: 1rem;
             text-align: center;
             /* box-shadow: inset 0 0 5px rgba(0,0,0,0.1); REMOVED */
        }
        #remaining-pc, #remaining-enemy {
            background-color: transparent; /* Make inner boxes transparent */
            padding: 0; /* Remove inner padding */
            border-radius: 0;
            border: none;
        }

        /* NEW: Custom styles for the large gradient numbers */
        .summary-count {
            font-size: 3rem; /* Large font size for emphasis */
            font-weight: 700;
            display: inline-block;
            line-height: 1;
            /* Apply Gradiant Text effect */
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            transition: all 0.3s;
        }
        #pc-count.summary-count {
            background-image: linear-gradient(180deg, var(--gradient-start), var(--pc-color));
        }
        #enemy-count.summary-count {
            background-image: linear-gradient(180deg, var(--gradient-start), var(--enemy-color));
        }
        
        /* NEW: Music Modal Range Slider Style */
        #music-volume-slider {
            background: linear-gradient(to right, var(--accent-primary), var(--accent-secondary));
            /* Apply theme colors to the thumb */
            --tw-ring-color: var(--accent-primary);
        }
        #music-volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: background 0.3s;
        }
        #music-volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: background 0.3s;
            border: none;
        }
        
        /* Volume Icon style */
        #volume-icon {
            color: var(--accent-primary);
        }

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 overflow-x-hidden pt-60">

    <!-- Hidden Music Player Container -->
    <div id="music-player-container" class="fixed bottom-0 left-0 w-1 h-1 overflow-hidden pointer-events-none">
        <div id="yt-player"></div>
    </div>
    
    <!-- Music Control Modal (User Volume Control) -->
    <div id="music-volume-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[85] hidden">
        <div class="modal-content rounded-md shadow-2xl p-6 w-full max-w-sm">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold font-title" style="color: var(--accent-primary);">Î∞∞Í≤Ω ÏùåÏïÖ Ï†úÏñ¥</h3>
                <button id="close-music-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button>
            </div>
            <div class="space-y-4">
                <p id="current-track-display" class="text-sm text-gray-400 truncate">ÌòÑÏû¨ Ìä∏Îûô: ÏóÜÏùå</p>
                <div class="flex items-center gap-4">
                    <button id="music-mute-toggle" class="p-2 bg-gray-600 hover:bg-gray-500 rounded-full">
                        <svg id="volume-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464A6.001 6.001 0 006 12a6.001 6.001 0 009.536 3.536L20.07 20.07A1 1 0 0021 20V4a1 1 0 00-.93-.93L15.536 8.464z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                    </button>
                    <input type="range" id="music-volume-slider" min="0" max="100" value="50" class="flex-grow h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>
        </div>
    </div>
    <!-- End Music Control Modal -->

    <!-- NEW: Utility Control Group (Bottom Right) -->
    <div id="utility-controls">
        <button id="music-control-btn" class="info-button p-3 rounded-full transition-transform hover:scale-110">
            <svg id="music-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19h12M9 19l-1 1m13-1l1 1m-4-6h.01M17 10h.01"></path></svg>
        </button>
        <button id="user-info-btn" class="info-button p-3 rounded-full transition-transform hover:scale-110">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
        </button>
        <button id="theme-toggle-btn" class="info-button p-3 rounded-full transition-transform hover:scale-110">
            <svg id="theme-icon-sun" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
            <svg id="theme-icon-moon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
        </button>
        <button id="admin-panel-btn" class="text-white font-bold p-3 rounded-full shadow-lg z-50 transition-transform hover:scale-110" style="background-color: var(--accent-primary); color: var(--bg-primary) !important;">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
        </button>
    </div>

    <!-- User Info Modal -->
    <div id="user-info-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[80] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-md">
            <h3 class="text-2xl font-bold mb-4 font-title" style="color: var(--accent-primary);">ÎÇ¥ Ï†ïÎ≥¥ Î∞è Í≤åÏûÑ ÏΩîÎìú</h3>
            
            <div class="mb-4 p-3 border border-border-secondary text-sm rounded-md">
                <p class="font-semibold text-gray-400 mb-1">Í≤åÏûÑ ÏΩîÎìú:</p>
                <div class="flex items-center gap-2">
                    <input readonly id="user-info-game-id-display" class="form-input text-center text-sm p-1 flex-grow" style="background-color: var(--bg-game-id);">
                    <button id="user-info-copy-btn" class="p-2 bg-gray-600 hover:bg-gray-500 rounded-md">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                    </button>
                </div>
            </div>

            <div class="mb-4 p-3 border border-border-secondary text-sm rounded-md">
                <p class="font-semibold text-gray-400 mb-1">ÌòÑÏû¨ Ïù∏Ï¶ù:</p>
                <span id="user-info-auth-char" class="font-bold text-lg" style="color: var(--accent-primary);">ÎπÑÎ°úÍ∑∏Ïù∏</span>
                <p class="text-xs text-gray-500 mt-1">Î°úÍ∑∏Ïù∏ÌïòÏó¨ Ï∫êÎ¶≠ÌÑ∞ Ï†úÏñ¥ Í∂åÌïúÏùÑ ÏñªÏúºÏÑ∏Ïöî.</p>
                <div class="mt-3 flex gap-2">
                    <button id="user-info-login-btn" class="text-sm bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 flex-grow hidden">Ï∫êÎ¶≠ÌÑ∞ Î°úÍ∑∏Ïù∏</button>
                    <button id="user-info-logout-btn" class="text-sm bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 flex-grow hidden">Î°úÍ∑∏ÏïÑÏõÉ</button>
                </div>
            </div>

            <button id="close-user-info-modal-btn" class="w-full mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2">Îã´Í∏∞</button>
        </div>
    </div>
    <!-- End User Info Modal -->

    <!-- Game Lobby Modal -->
    <div id="game-lobby-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[100]">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-md">
            <h2 class="text-3xl font-bold mb-6 text-center" style="color: var(--accent-primary);">Í≤åÏûÑ Ï∞∏Í∞Ä</h2>
            <p class="text-center mb-6" style="color: var(--text-secondary);">ÏÉà Í≤åÏûÑÏùÑ ÎßåÎì§Í±∞ÎÇò, ÏπúÍµ¨ÏóêÍ≤å Î∞õÏùÄ ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏó¨ Ï∞∏Í∞ÄÌïòÏÑ∏Ïöî.</p>
            <div class="space-y-4">
                <button id="create-game-btn" class="w-full bg-green-600 text-black font-bold py-3 px-4 transition-transform hover:scale-105">ÏÉà Í≤åÏûÑ ÎßåÎì§Í∏∞</button>
                <div class="flex items-center"><hr class="flex-grow border-gray-600"><span class="px-4 text-gray-400">ÎòêÎäî</span><hr class="flex-grow border-gray-600"></div>
                <div class="flex gap-2">
                    <input type="text" id="game-id-input" placeholder="Í≤åÏûÑ ÏΩîÎìú ÏûÖÎ†•" class="form-input flex-grow">
                    <button id="join-game-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4">Ï∞∏Í∞ÄÌïòÍ∏∞</button>
                </div>
            </div>
        </div>
    </div>

    <!-- PC Login Modal (New) -->
    <div id="pc-login-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[90] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 font-title" style="color: var(--accent-primary);">Ï∫êÎ¶≠ÌÑ∞ Î°úÍ∑∏Ïù∏</h3>
            <p class="mb-4 text-gray-400">Ï†úÏñ¥Ìï† Ï∫êÎ¶≠ÌÑ∞ Ïù¥Î¶ÑÍ≥º Ï¥àÍ∏∞ ÎπÑÎ∞ÄÎ≤àÌò∏(1234)Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.</p>
            <select id="char-login-name-select" class="form-input mb-4"></select>
            <input type="password" id="char-login-password-input" class="form-input text-center" placeholder="ÎπÑÎ∞ÄÎ≤àÌò∏ (Ï¥àÍ∏∞: 1234)">
            <p id="char-login-error" class="text-red-500 text-sm mt-2 h-4"></p>
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancel-char-login-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4">Ï∑®ÏÜå</button>
                <button id="submit-char-login-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4">Î°úÍ∑∏Ïù∏</button>
            </div>
        </div>
    </div>
    
    <!-- Character Selection Overlay -->
    <div id="character-selection-overlay" class="flex flex-col justify-start fixed top-0 left-0 w-full z-40">
        <div id="selection-list-wrapper" class="overflow-hidden h-full flex items-center transition-opacity duration-300 ease-in-out">
            <div id="selection-list" class="flex mx-auto p-4 gap-4 max-w-7xl w-full overflow-x-auto whitespace-nowrap justify-start">
                 <div class="text-white/70 text-lg w-full text-center p-4">Ïù∏Ï¶ù Ï§ë...</div>
            </div>
        </div>
        <!-- NEW: Toggle button moved to the right -->
        <button id="overlay-toggle" class="absolute top-full right-4 transform bg-gray-700/90 hover:bg-gray-600/90 text-white p-2 rounded-b-lg z-50 transition-colors shadow-lg">
             <svg id="toggle-icon" class="w-5 h-5 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg>
        </button>
    </div>
    
    <!-- Main Content Area -->
    <div class="w-full max-w-7xl mx-auto flex flex-col lg:flex-row gap-8">
        <!-- Left: Control Panel -->
        <div class="panel lg:w-1/4 w-full p-6 shadow-lg flex flex-col">
            <div>
                <div class="flex justify-between items-center mb-2">
                    <h1 class="text-xl font-bold font-title" style="color: var(--accent-primary);">Í≤åÏûÑ ÏÉÅÌÉú</h1>
                </div>
                
                <!-- UPDATED: Remaining Units Summary (Applied Stylish Box, now transparent) -->
                <div id="unit-summary" class="mb-4">
                    <div id="remaining-pc" class="text-center">
                        <p class="text-xs text-gray-400">ÎÇ®ÏùÄ ÏïÑÍµ∞</p>
                        <span id="pc-count" class="summary-count">0</span>
                    </div>
                    <div id="remaining-enemy" class="text-center">
                        <p class="text-xs text-gray-400">ÎÇ®ÏùÄ Ï†ÅÍµ∞</p>
                        <span id="enemy-count" class="summary-count">0</span>
                    </div>
                </div>

                <!-- Game ID Display (REMOVED from UI flow) -->
                 <div id="game-id-container" class="hidden">
                    <p class="text-xs font-semibold" style="color: var(--text-secondary);">Í≤åÏûÑ ÏΩîÎìú:</p>
                    <div class="flex items-center gap-2 mt-1">
                        <input readonly id="game-id-display" class="form-input text-center text-sm p-1" style="background-color: var(--bg-game-id);">
                        <button id="copy-game-id-btn" class="p-2 bg-gray-600 hover:bg-gray-500">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                        </button>
                    </div>
                </div>
                <!-- Auth Status (Hidden, moved to User Info Modal) -->
                <div id="auth-status" class="hidden">
                    <p class="font-semibold text-gray-400">ÌòÑÏû¨ Ïù∏Ï¶ù:</p>
                    <span id="current-auth-char" class="text-yellow-400 font-bold">ÎπÑÎ°úÍ∑∏Ïù∏</span>
                    <button id="login-btn" class="text-xs ml-2 text-indigo-500 hover:text-indigo-300 hidden">Î°úÍ∑∏Ïù∏</button>
                    <button id="logout-btn" class="text-xs ml-2 text-red-500 hover:text-red-300 hidden">Î°úÍ∑∏ÏïÑÏõÉ</button>
                </div>
                <!-- End Hidden Elements -->

                <div id="turn-status" class="mb-4 stylish-turn-box" >
                    <p class="text-sm font-semibold" style="color: var(--accent-primary);">ÌòÑÏû¨ ÌÑ¥:</p>
                    <div id="current-turn-char" class="text-xl font-bold font-title" style="color: var(--accent-secondary);">Ï§ÄÎπÑ Ï§ë...</div>
                </div>
                <div id="skill-controls" class="mt-4 pb-4 border-b border-border-secondary">
                     <p class="text-sm" style="color: var(--text-tertiary);">Ï∫êÎ¶≠ÌÑ∞Î•º ÏÑ†ÌÉùÌïòÎ©¥ Ïä§ÌÇ¨Ïù¥ ÌëúÏãúÎê©ÎãàÎã§.</p>
                </div>
                <div id="character-list" class="mt-4 flex-grow">
                    <h2 class="text-lg font-bold pb-2 mb-2 font-title" style="color: var(--text-secondary); border-bottom: 1px solid var(--border-secondary);">Ï∫êÎ¶≠ÌÑ∞ ÏÉÅÌÉú</h2>
                    <div id="char-list-content" class="max-h-96 overflow-y-auto space-y-2">
                        <p style="color: var(--text-tertiary);" class="text-sm">Í≤åÏûÑÏóê Ï∞∏Ïó¨Ìï¥Ï£ºÏÑ∏Ïöî...</p>
                    </div>
                </div>
            </div>
            <div class="mt-auto pt-4">
                <button id="leave-game-btn" class="w-full bg-red-600 font-bold py-2 px-4">Í≤åÏûÑ ÎÇòÍ∞ÄÍ∏∞</button>
            </div>
        </div>

        <!-- Center: Game Board -->
        <div class="lg:w-2/4 w-full flex items-center justify-center">
            <div id="game-board" class="shadow-inner"></div>
        </div>

        <!-- Right: Game Log -->
        <div id="log-panel" class="panel lg:w-1/4 w-full p-6 shadow-lg">
             <h2 class="text-lg font-bold pb-2 mb-4 font-title" style="color: var(--text-secondary); border-bottom: 1px solid var(--border-secondary);">Í≤åÏûÑ Î°úÍ∑∏</h2>
             <ul id="game-log-list" class="h-[75vh] overflow-y-auto space-y-2 text-sm pr-2">
                <li class="log-system">Í≤åÏûÑ Î°úÍ∑∏Î•º Í∏∞Îã§Î¶¨Îäî Ï§ë...</li>
             </ul>
        </div>
    </div>

    <!-- Modals -->
    <div id="profile-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-50 hidden"><div id="modal-content" class="w-full max-w-[900px]"></div></div>
    <div id="custom-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-50 hidden"><div id="custom-modal-content" class="modal-content rounded-md shadow-2xl p-8 w-full max-w-sm"><h3 id="custom-modal-title" class="text-xl font-bold mb-4 font-title"></h3><p id="custom-modal-message" class="mb-6"></p><div id="custom-modal-buttons" class="flex justify-end gap-4"></div></div></div>
    <div id="admin-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[60] hidden"><div id="admin-modal-content" class="modal-content rounded-md shadow-2xl p-8 w-full max-w-3xl max-h-[90vh] overflow-y-auto"><div class="flex justify-between items-center mb-6"><h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">Í¥ÄÎ¶¨Ïûê Ìå®ÎÑê</h3><button id="close-admin-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button></div><div id="admin-skill-list" class="space-y-4"></div></div></div>
    <div id="admin-password-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[70] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 font-title">Í¥ÄÎ¶¨Ïûê Ïù∏Ï¶ù</h3>
            <p class="mb-4 text-gray-400">Í¥ÄÎ¶¨Ïûê ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.</p>
            <input type="password" id="admin-password-input" class="form-input text-center">
            <p id="admin-password-error" class="text-red-500 text-sm mt-2 h-4"></p>
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancel-admin-login-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4">Ï∑®ÏÜå</button>
                <button id="submit-admin-login-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4">ÌôïÏù∏</button>
            </div>
        </div>
    </div>
    
    <!-- Map Edit Modal (New) -->
    <div id="map-edit-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[65] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-lg max-h-[90vh] overflow-y-auto">
            <!-- X Î≤ÑÌäº Ï∂îÍ∞Ä Î∞è Ï†úÎ™© Ïª®ÌÖåÏù¥ÎÑà ÏàòÏ†ï -->
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">Îßµ Ìé∏Ïßë Î™®Îìú (Í¥ÄÎ¶¨Ïûê)</h3>
                <button id="close-map-edit-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button>
            </div>
            <!-- End Modified header -->
            <p class="mb-4 text-gray-400">Î≥¥Îìú Ïπ∏ÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ ÏßÄÌòïÏùÑ ÏÑ§Ï†ïÌïòÏÑ∏Ïöî. Ï§ÄÎπÑ Îã®Í≥ÑÏóêÏÑúÎßå ÏûëÎèôÌï©ÎãàÎã§.</p>
            <div class="space-y-4">
                <div class="flex gap-4 p-4 border border-gray-700 rounded-md">
                    <button data-tile-type="normal" class="tile-select-btn flex-grow p-3 bg-gray-600 hover:bg-gray-500 text-white">ÏùºÎ∞ò Ïπ∏</button>
                    <button data-tile-type="obstacle" class="tile-select-btn flex-grow p-3 bg-gray-700 hover:bg-gray-600 text-white tile-obstacle">Ïû•Ïï†Î¨º (Ïù¥Îèô Î∂àÍ∞Ä) üö´</button>
                    <button data-tile-type="damage" class="tile-select-btn flex-grow p-3 bg-red-800 hover:bg-red-700 text-white tile-damage">ÎåÄÎØ∏ÏßÄ Ïπ∏ (ÌÑ¥ ÏãúÏûë Ïãú $10$ ÌîºÌï¥) ü©∏</button>
                </div>
                <div id="map-edit-status" class="text-center font-bold text-lg text-green-400">ÌòÑÏû¨ ÏÑ†ÌÉù: ÏùºÎ∞ò Ïπ∏</div>
                <button id="exit-map-edit-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3">Îßµ Ìé∏Ïßë Ï¢ÖÎ£å</button>
            </div>
        </div>
    </div>


<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, onSnapshot, doc, updateDoc, query, getDocs, writeBatch, getDoc, setDoc, addDoc, serverTimestamp, orderBy, deleteDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    // IMPORTANT: In a real environment, these configs should be loaded securely.
    const firebaseConfig = {
        apiKey: "AIzaSyDwTxRX9oUSYVKlhX2k2s7147vQ4MGHj2g",
        authDomain: "battlemap-5525d.firebaseapp.com",
        projectId: "battlemap-5525d",
        storageBucket: "battlemap-5525d.appspot.com",
        messagingSenderId: "907555037353",
        appId: "1:907555037353:web:04034cc19b0f9fe64f49b8"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // --- Global YouTube Player Variables ---
    window.ytPlayer = null;
    window.isPlayerReady = false;
    let localVolume = parseInt(localStorage.getItem('musicVolume')) || 50; // User's local volume setting
    let localMuted = localStorage.getItem('musicMuted') === 'true';
    let currentTrackId = null; // Track ID currently loaded in the player

    // YouTube API Ready Callback (MUST be global)
    window.onYouTubeIframeAPIReady = () => {
        window.isPlayerReady = true;
        console.log("YouTube API Ready.");
        // Firebase listener will handle loading the player
        if (currentTrackId) {
            loadPlayer(currentTrackId, true);
        }
    };

    // --- Global Variables ---
    const BOARD_SIZE = 10;
    let characters = [];
    let selectedCharacterId = null;
    let userId = null;
    let gameId = null; 
    let unsubscribeChars = null;
    let unsubscribeSettings = null;
    let unsubscribeLogs = null;
    let isBoardInitialized = false; 
    let selectedSkill = null; 
    let currentTurnIndex = 0;
    let turnPhase = 'MOVE';
    let isProcessingTurn = false;
    let preMovePosition = null; 
    let gameState = 'PREPARATION';
    let round = 1;
    let maxRounds = 0;
    
    let loggedInCharId = null; 
    let isAdmin = false;       
    let isAdminMoveAllowed = true; 
    const DEFAULT_PC_PASSWORD = "1234";
    
    // NEW: Map/Board State Variables
    let boardTiles = {}; // Stores map features { "x,y": { type: 'obstacle' | 'damage' | 'normal', data: {} } }
    let isMapEditMode = false; // Flag for admin map editing
    let currentTileType = 'normal'; // The tile type the admin is currently placing
    const DAMAGE_TILE_DAMAGE = 10;
    const MP_REGEN_PER_TURN = 10; // New: Mana regeneration per turn

    const DEFAULT_SKILLS = {
        'move': { id: 'move', name: 'Ïù¥Îèô', type: 'Utility', range: 2, rangeShape: 'diamond', multiplier: 0, icon: 'üèÉ', mpCost: 0, category: 'Utility' }, // Í∏∞Î≥∏ Ïù¥Îèô Í±∞Î¶¨Î•º 2Î°ú ÏÑ§Ï†ï
        'slash': { id: 'slash', name: 'Î≤†Í∏∞', type: 'Melee', range: 1, rangeShape: 'diamond', multiplier: 1.5, icon: '‚öîÔ∏è', mpCost: 5, category: 'Attack' },
        'stomp': { id: 'stomp', name: 'Î∞ú Íµ¨Î•¥Í∏∞', type: 'Melee', range: 1, rangeShape: 'square', multiplier: 1.2, icon: 'üí•', mpCost: 8, category: 'Attack'},
        'crosscut': { id: 'crosscut', name: 'Ïã≠Ïûê Î≤†Í∏∞', type: 'Melee', range: 2, rangeShape: 'cross', multiplier: 1.0, icon: 'ÂçÅÂ≠ó', mpCost: 10, category: 'Attack'},
        'shoot': { id: 'shoot', name: 'ÏÇ¨Í≤©', type: 'Ranged', range: 4, rangeShape: 'diamond', multiplier: 1.0, icon: 'üèπ', mpCost: 5, category: 'Attack' },
        'fireball': { id: 'fireball', name: 'ÌôîÏóºÍµ¨', type: 'Ranged', range: 3, rangeShape: 'square', multiplier: 1.0, icon: 'üî•', isAoe: true, aoeRange: 1, aoeShape: 'square', mpCost: 15, category: 'Attack' },
        'heal': { id: 'heal', name: 'ÏπòÏú†Ïùò Îπõ', type: 'Heal', range: 2, rangeShape: 'diamond', multiplier: 1.0, icon: '‚ú®', targetType: 'ALLY', mpCost: 10, category: 'Support' },
        
        // NEW SKILLS
        'resurrect': { id: 'resurrect', name: 'Î∂ÄÌôúÏùò Ï£ºÎ¨∏', type: 'Heal', range: 1, rangeShape: 'diamond', multiplier: 0.3, icon: 'üëº', targetType: 'ALLY_DEAD', mpCost: 50, category: 'Support' }, // HP 30% Î∂ÄÌôú, MP 0ÏúºÎ°ú
        'hp_transfer': { id: 'hp_transfer', name: 'ÏÉùÎ™ÖÎ†• Ï†ÑÎã¨', type: 'Heal', range: 2, rangeShape: 'diamond', multiplier: 1.5, icon: 'üíñ', targetType: 'ALLY', mpCost: 0, hpCost: 20, category: 'Support' }, // HP 20 ÏÜåÎ™®, 30 ÌöåÎ≥µ
        'mp_transfer': { id: 'mp_transfer', name: 'ÎßàÎÇò Ï†ÑÎã¨', type: 'Support', range: 2, rangeShape: 'diamond', multiplier: 30, icon: 'üíß', targetType: 'ALLY', mpCost: 10, category: 'Support' }, // MP 10 ÏÜåÎ™®, 30 MP Ï†ÑÎã¨
    };
    let SKILLS = {};
    
    // Ïä§ÌÇ¨ Ïπ¥ÌÖåÍ≥†Î¶¨ ÏàúÏÑú Ï†ïÏùò
    const SKILL_CATEGORIES = ['Attack', 'Support', 'Heal', 'Utility', 'Defense', 'Other'];


    // --- UI Elements ---
    const gameBoard = document.getElementById('game-board');
    const profileModal = document.getElementById('profile-modal');
    const skillControls = document.getElementById('skill-controls');
    const turnStatus = document.getElementById('current-turn-char');
    const lobbyModal = document.getElementById('game-lobby-modal');
    const pcLoginModal = document.getElementById('pc-login-modal');
    const createGameBtn = document.getElementById('create-game-btn');
    const joinGameBtn = document.getElementById('join-game-btn');
    const gameIdInput = document.getElementById('game-id-input');
    const gameIdDisplay = document.getElementById('game-id-display');
    const copyGameIdBtn = document.getElementById('copy-game-id-btn');
    const adminModal = document.getElementById('admin-modal');
    const adminPasswordModal = document.getElementById('admin-password-modal');
    const leaveGameBtn = document.getElementById('leave-game-btn');
    const currentAuthChar = document.getElementById('current-auth-char');
    const logoutBtn = document.getElementById('logout-btn');
    const loginBtn = document.getElementById('login-btn');
    const mapEditModal = document.getElementById('map-edit-modal'); // NEW map edit modal
    // NEW User Info Modal elements
    const userInfoBtn = document.getElementById('user-info-btn');
    const userInfoModal = document.getElementById('user-info-modal');

    // NEW Music Control Elements
    const musicControlBtn = document.getElementById('music-control-btn');
    const musicVolumeModal = document.getElementById('music-volume-modal');


    // --- Music Player Functions ---

    // Function to extract YouTube ID from URL
    function extractYouTubeId(url) {
        if (!url) return null;
        const regex = /(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }

    function loadPlayer(videoId, autoPlay = false) {
        if (!window.isPlayerReady || !videoId) {
            console.error("YouTube API not ready or no video ID.");
            currentTrackId = videoId;
            return;
        }
        
        currentTrackId = videoId;
        
        if (window.ytPlayer) {
            // Player exists, just load new video
            window.ytPlayer.loadVideoById({
                'videoId': videoId,
                'startSeconds': 0,
                'suggestedQuality': 'small'
            });
            updateVolume(localVolume); // Reapply user's volume
            if (autoPlay) {
                 window.ytPlayer.playVideo();
            }
            return;
        }
        
        // Create new player
        window.ytPlayer = new YT.Player('yt-player', {
            videoId: videoId,
            playerVars: {
                'autoplay': autoPlay ? 1 : 0, // Start playback
                'controls': 0,
                'loop': 1,
                'disablekb': 1,
                'fs': 0,
                'modestbranding': 1,
                'rel': 0,
                'showinfo': 0,
                'iv_load_policy': 3,
                'playlist': videoId, // For seamless looping
                'wmode': 'transparent'
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    }

    function onPlayerReady(event) {
        console.log("YouTube Player Ready.");
        window.isPlayerReady = true;
        // Apply user's local volume setting
        updateVolume(localVolume);
    }

    function onPlayerStateChange(event) {
        // Handle ended state to ensure looping (if playerVars.loop wasn't enough)
        if (event.data === YT.PlayerState.ENDED) {
            event.target.seekTo(0);
            event.target.playVideo();
        }
    }

    function updateVolume(newVolume) {
        localVolume = newVolume;
        localStorage.setItem('musicVolume', newVolume);
        
        const effectiveVolume = localMuted ? 0 : localVolume;

        if (window.ytPlayer && window.isPlayerReady && typeof window.ytPlayer.setVolume === 'function') {
            window.ytPlayer.setVolume(effectiveVolume);
        }
        
        // Update modal UI
        const slider = document.getElementById('music-volume-slider');
        const volumeIconEl = document.getElementById('volume-icon');
        
        if (slider) slider.value = localVolume;
        
        if (volumeIconEl) {
            if (localMuted || localVolume === 0) {
                volumeIconEl.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464A6.001 6.001 0 006 12a6.001 6.001 0 009.536 3.536L20.07 20.07A1 1 0 0021 20V4a1 1 0 00-.93-.93L15.536 8.464z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.914 17.914l-6.364-6.364"></path>`; // Mute with slash
            } else {
                volumeIconEl.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19h12M9 19l-1 1m13-1l1 1m-4-6h.01M17 10h.01"></path>`; // Generic music icon
            }
        }
    }

    function toggleMute() {
        localMuted = !localMuted;
        localStorage.setItem('musicMuted', localMuted ? 'true' : 'false');
        updateVolume(localVolume); // Reapply volume to update player and icon
    }

    // --- Game Lobby ---
    function generateGameId() { return Math.random().toString(36).substring(2, 8).toUpperCase(); }

    async function deleteLogsCollection(gameId) {
        if (!gameId) return;
        try {
            const logsRef = collection(db, "games", gameId, "logs");
            const snapshot = await getDocs(logsRef);
            if (!snapshot.empty) {
                const batch = writeBatch(db);
                snapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
                console.log(`Logs cleared for game: ${gameId}`);
            }
        } catch (error) {
            console.error("Error clearing logs:", error);
        }
    }

    async function createGame() { await joinGame(generateGameId(), true); }
    async function joinGame(id, isNewGame = false) {
        if (!id || id.trim().length === 0) { showCustomModal("Ïò§Î•ò", "Ïú†Ìö®Ìïú Í≤åÏûÑ ÏΩîÎìúÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.", [{ text: "ÌôïÏù∏", class: "bg-red-600" }]); return; }
        gameId = id.trim().toUpperCase();

        if (!isNewGame) {
            const docSnap = await getDoc(doc(db, "games", gameId));
            if (!docSnap.exists()) { showCustomModal("Ï∞∏Í∞Ä Ïã§Ìå®", "Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Í≤åÏûÑ ÏΩîÎìúÏûÖÎãàÎã§.", [{ text: "ÌôïÏù∏", class: "bg-red-600" }]); gameId = null; return; }
        }

        localStorage.setItem('currentGameId', gameId);
        lobbyModal.classList.add('hidden');
        gameIdDisplay.value = gameId;

        if (isNewGame) {
            await deleteLogsCollection(gameId);
            await seedInitialSettings(gameId);
            await seedInitialCharacters(gameId);
            // NEW: Seed initial board tiles (all normal)
            await setDoc(doc(db, 'games', gameId, 'board', 'tiles'), { tiles: {} });
            await logAction("‚öîÔ∏è ÏÉàÎ°úÏö¥ Í≤åÏûÑÏù¥ ÏãúÏûëÎêòÏóàÏäµÎãàÎã§! Í≤åÏûÑ Î°úÍ∑∏Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.", "system");
        }
        listenForGameData(gameId);
        openPCLoginModal();
    }
    function leaveGame() { localStorage.removeItem('currentGameId', gameId); location.reload(); }

    // --- Authentication ---
    onAuthStateChanged(auth, (user) => {
        if (user) {
            userId = user.uid;
            const savedGameId = localStorage.getItem('currentGameId');
            if (savedGameId) { joinGame(savedGameId); } 
            else { lobbyModal.classList.remove('hidden'); }
        } else { signInAnonymously(auth).catch((error) => console.error("Anonymous sign-in failed:", error)); }
    });
    
    // --- Data Seeding ---
    async function seedInitialSettings(gameId) { 
        await setDoc(doc(db, 'games', gameId), { 
            skills: DEFAULT_SKILLS, 
            currentTurnIndex: 0, 
            currentTurnCharId: null, 
            adminPassword: "0000", 
            gameState: 'PREPARATION', 
            round: 1, 
            maxRounds: 0, 
            isAdminMoveAllowed: true,
            musicUrl: '',
            musicName: ''
        }); 
    }
    async function seedInitialCharacters(gameId) {
        const charCollectionRef = collection(db, "games", gameId, "characters");
        const snapshot = await getDocs(charCollectionRef);
        if (snapshot.empty) {
            const batch = writeBatch(db);
            const pcData = [ 
                { name: "Shadow Assassin", img: "https://cdn.pixabay.com/photo/2023/12/15/21/47/cat-8451431_1280.jpg", type: 'PC', size: 1, skills: ['slash', 'shoot', 'heal', 'hp_transfer'], order: 1 }, // Added hp_transfer
                { name: "Steel Guardian", img: "https://cdn.pixabay.com/photo/2023/12/15/21/47/cat-8451431_1280.jpg", type: 'PC', size: 1, skills: ['crosscut', 'resurrect', 'mp_transfer'], order: 3 }, // Added resurrect, mp_transfer
            ];
            const enemyData = [ 
                { name: "Dark Knight", img: "https://cdn.pixabay.com/photo/2015/05/22/05/52/cat-778315_1280.jpg", type: 'ENEMY', size: 1, skills: ['slash'], order: 2 }, 
                { name: "Abyssal Golem", img: "https://cdn.pixabay.com/photo/2015/05/22/05/52/cat-778315_1280.jpg", type: 'ENEMY', size: 2, skills: ['stomp'], order: 4 }, 
            ];
            [...pcData, ...enemyData].forEach(char => {
                const charPassword = char.type === 'PC' ? DEFAULT_PC_PASSWORD : ''; 
                // ADDED MP stats
                const newChar = { name: char.name, imageUrl: char.img || '', type: char.type, size: char.size, hp: 100, maxHp: 100, mp: 50, maxMp: 50, minAttack: 12, maxAttack: 18, minDefense: 3, maxDefense: 7, x: null, y: null, skills: char.skills || [], turnOrder: char.order, password: charPassword };
                batch.set(doc(charCollectionRef), newChar);
            });
            await batch.commit();
        }
    }
    
    // --- Data Listeners ---
    function listenForGameData(gameId) {
        if (unsubscribeSettings) unsubscribeSettings();
        if (unsubscribeChars) unsubscribeChars();
        if (unsubscribeLogs) unsubscribeLogs();

        unsubscribeSettings = onSnapshot(doc(db, 'games', gameId), (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                SKILLS = data.skills || {};
                gameState = data.gameState || 'PREPARATION';
                round = data.round || 1;
                maxRounds = data.maxRounds || 0;
                isAdminMoveAllowed = data.isAdminMoveAllowed !== undefined ? data.isAdminMoveAllowed : true;
                const turnCharId = data.currentTurnCharId;
                currentTurnIndex = characters.findIndex(c => c.id === turnCharId);
                if (currentTurnIndex === -1) currentTurnIndex = 0;
                if (!adminModal.classList.contains('hidden')) openAdminModal();
                
                // NEW: Music Control Update
                const musicUrl = data.musicUrl;
                const musicName = data.musicName || "Ïû¨ÏÉù Ï§ëÏù∏ Ìä∏Îûô ÏóÜÏùå";
                document.getElementById('current-track-display').textContent = `ÌòÑÏû¨ Ìä∏Îûô: ${musicName}`;
                const newTrackId = extractYouTubeId(musicUrl);
                
                if (newTrackId && newTrackId !== currentTrackId) {
                     loadPlayer(newTrackId);
                     logAction(`üéµ Í¥ÄÎ¶¨ÏûêÍ∞Ä Î∞∞Í≤Ω ÏùåÏïÖÏùÑ '${musicName}'(Ïúº)Î°ú Î≥ÄÍ≤ΩÌñàÏäµÎãàÎã§.`, "system");
                } else if (!newTrackId && currentTrackId && window.ytPlayer) {
                     if (typeof window.ytPlayer.stopVideo === 'function') {
                        window.ytPlayer.stopVideo();
                     }
                     currentTrackId = null;
                     logAction(`üîá Í¥ÄÎ¶¨ÏûêÍ∞Ä Î∞∞Í≤Ω ÏùåÏïÖ Ïû¨ÏÉùÏùÑ Ï§ëÏßÄÌñàÏäµÎãàÎã§.`, "system");
                }


                // NEW: Check for map features and fetch them
                onSnapshot(doc(db, 'games', gameId, 'board', 'tiles'), (tileDoc) => {
                    boardTiles = tileDoc.data()?.tiles || {};
                    render();
                });

                render();
            }
        });

        unsubscribeChars = onSnapshot(query(collection(db, "games", gameId, "characters")), (snapshot) => {
            characters = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })).sort((a, b) => a.turnOrder - b.turnOrder);
            // Ensure MP defaults are set if missing (for older entries)
            characters.forEach(char => {
                if (char.mp === undefined || char.maxMp === undefined) {
                    char.mp = char.maxMp = 50; 
                }
            });
            if (!pcLoginModal.classList.contains('hidden')) populatePCLoginSelect(); 
            render();
        });

        unsubscribeLogs = onSnapshot(query(collection(db, "games", gameId, "logs"), orderBy("timestamp", "desc")), (snapshot) => {
            renderLogs(snapshot.docs.map(doc => doc.data()));
        });
    }
    
    // --- Game Logic ---
    async function logAction(message, type = "system") { if (gameId) await addDoc(collection(db, "games", gameId, "logs"), { message, type, timestamp: serverTimestamp() }); }
    
    // NEW: Function to check for damage tile and apply damage if necessary
    async function checkAndApplyTileDamage(char) {
        if (char.x === null || char.hp <= 0) return;

        const tileKey = `${char.x},${char.y}`;
        const tile = boardTiles[tileKey];

        if (tile && tile.type === 'damage') {
            const damage = DAMAGE_TILE_DAMAGE;
            const newHp = Math.max(0, char.hp - damage);
            
            await updateDoc(doc(db, 'games', gameId, 'characters', char.id), { hp: newHp });

            let message = `ü©∏ ${char.name}Ïù¥(Í∞Ä) ÎåÄÎØ∏ÏßÄ Ïπ∏Ïóê ÏÑúÏûàÏñ¥ **${damage} ÌîºÌï¥**Î•º ÏûÖÏóàÏäµÎãàÎã§!`;
            if (newHp === 0) message += `<br>üíÄ ${char.name}Ïù¥(Í∞Ä) Ïì∞Îü¨Ï°åÏäµÎãàÎã§!`;
            await logAction(message, "damage");
        }
    }

    async function updateTurnIndex(newIndex, reverse = false) {
        if (characters.length === 0 || !gameId) return;
        
        let newRound = round;
        if (!reverse && newIndex < currentTurnIndex) {
            newRound++;
            await logAction(`‚ñ∂Ô∏è ÎùºÏö¥Îìú ${newRound} ÏãúÏûë`, "system");
        } else if (reverse && newIndex > currentTurnIndex) {
            if (newRound > 1) {
                newRound--;
                await logAction(`‚óÄÔ∏è Ïù¥Ï†Ñ ÎùºÏö¥ÎìúÎ°ú ÎèåÏïÑÍ∞ëÎãàÎã§. (ÎùºÏö¥Îìú ${newRound})`, "system");
            }
        }
        
        currentTurnIndex = newIndex % characters.length;
        const currentTurnChar = characters[currentTurnIndex];
        const currentTurnCharId = currentTurnChar?.id || null;

        if (maxRounds > 0 && newRound > maxRounds) {
            await setDoc(doc(db, 'games', gameId), { gameState: 'ENDED', round: newRound, currentTurnIndex, currentTurnCharId }, { merge: true });
            showCustomModal("Ï†ÑÌà¨ Ï¢ÖÎ£å", `ÏµúÎåÄ ÎùºÏö¥Îìú(${maxRounds})Ïóê ÎèÑÎã¨ÌïòÏó¨ Ï†ÑÌà¨Í∞Ä Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.`, [{text: "ÌôïÏù∏", class:"bg-green-600"}]);
            await logAction(`- Ï†ÑÌà¨ Ï¢ÖÎ£å: ÏµúÎåÄ ÎùºÏö¥Îìú ÎèÑÎã¨ -`, "system");
        } else {
            await setDoc(doc(db, 'games', gameId), { round: newRound, currentTurnIndex, currentTurnCharId }, { merge: true });
            
            if (gameState === 'STARTED' && currentTurnChar) {
                // 1. MP Regeneration
                if (!reverse) {
                    const newMp = Math.min(currentTurnChar.maxMp, currentTurnChar.mp + MP_REGEN_PER_TURN);
                    if (newMp > currentTurnChar.mp) {
                        await updateDoc(doc(db, 'games', gameId, 'characters', currentTurnChar.id), { mp: newMp });
                        await logAction(`üíß ${currentTurnChar.name}Ïù¥(Í∞Ä) **${MP_REGEN_PER_TURN} MP**Î•º ÌöåÎ≥µÌñàÏäµÎãàÎã§.`, "system");
                    }
                }
                
                // 2. Tile Damage Check
                if (!reverse) {
                    await checkAndApplyTileDamage(currentTurnChar);
                }
            }
        }
    }

    async function nextTurn() {
        if (characters.length === 0 || !gameId) return;
        turnPhase = 'MOVE';
        selectedSkill = 'move';
        let nextIndex = currentTurnIndex;
        do {
            nextIndex = (nextIndex + 1) % characters.length;
        } while (characters.length > 1 && characters[nextIndex] && (characters[nextIndex].hp <= 0 || characters[nextIndex].x === null));
        
        await updateTurnIndex(nextIndex);
        selectedCharacterId = null;
    }
    
    async function previousTurn() {
        if (characters.length === 0 || !gameId) return;
        turnPhase = 'MOVE';
        selectedSkill = 'move';
        let prevIndex = currentTurnIndex;
        do {
            prevIndex = (prevIndex - 1 + characters.length) % characters.length;
        } while (characters.length > 1 && characters[prevIndex] && (characters[prevIndex].hp <= 0 || characters[prevIndex].x === null));

        await updateTurnIndex(prevIndex, true);
        selectedCharacterId = null;
    }

    // Helper function to handle HP change
    async function updateHP(char, amount, logType) {
        const newHp = Math.min(char.maxHp, Math.max(0, char.hp + amount));
        await updateDoc(doc(db, 'games', gameId, 'characters', char.id), { hp: newHp });
        return newHp;
    }
    
    // Helper function to handle MP change
    async function updateMP(char, amount) {
         const newMp = Math.min(char.maxMp, Math.max(0, char.mp + amount));
         await updateDoc(doc(db, 'games', gameId, 'characters', char.id), { mp: newMp });
         return newMp;
    }


    function findTargetsInAoe(centerX, centerY, range, shape, skillType, attackerType) {
        const affectedCells = new Set();
        for (let dy = -range; dy <= range; dy++) {
            for (let dx = -range; dx <= range; dx++) {
                let inShape = (shape === 'diamond' && Math.abs(dx) + Math.abs(dy) <= range) || (shape === 'square');
                if (inShape) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) affectedCells.add(`${x},${y}`);
                }
            }
        }
        
        const targets = new Set();
        characters.forEach(char => {
            if (char.x !== null) {
                const isEnemy = char.type !== attackerType;
                const isAlly = char.type === attackerType;
                
                let isEligible = false;
                
                // Standard damage/heal targeting
                if ((skillType === 'Heal' || skillType === 'Support') && isAlly && char.hp > 0) isEligible = true;
                if (skillType !== 'Heal' && skillType !== 'Support' && isEnemy && char.hp > 0) isEligible = true;
                
                // Special case for Resurrect
                const skill = SKILLS[selectedSkill];
                if (skill && skill.targetType === 'ALLY_DEAD' && isAlly && char.hp <= 0) isEligible = true;

                if (isEligible) {
                    const size = char.size || 1;
                    for (let ex = 0; ex < size; ex++) {
                        for (let ey = 0; ey < size; ey++) {
                            if (affectedCells.has(`${char.x + ex},${char.y + ey}`)) {
                                targets.add(char);
                                break;
                            }
                        }
                    }
                }
            }
        });
        return Array.from(targets);
    }

    async function applyDamage(attacker, defender, skillId) {
        const skill = SKILLS[skillId];
        if (!skill) return;
        
        // Mana Check
        if (attacker.mp < skill.mpCost) {
             await logAction(`‚ö†Ô∏è ${attacker.name}Ïù¥(Í∞Ä) ÎßàÎÇòÍ∞Ä Î∂ÄÏ°±ÌïòÏó¨ ${skill.name}ÏùÑ(Î•º) ÏãúÏ†ÑÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. (ÌïÑÏöî: ${skill.mpCost}, ÌòÑÏû¨: ${attacker.mp})`, "system");
             return false;
        }

        // Consume MP
        await updateMP(attacker, -skill.mpCost);

        const defenderToken = document.querySelector(`.character-token[data-char-id="${defender.id}"]`);
        if (defenderToken) {
            defenderToken.classList.add('hit-animation', 'show-hit-overlay');
            setTimeout(() => {
                defenderToken.classList.remove('hit-animation');
                defenderToken.classList.remove('show-hit-overlay');
            }, 1000);
        }

        const currentAttack = Math.floor(Math.random() * (attacker.maxAttack - attacker.minAttack + 1)) + attacker.minAttack;
        const currentDefense = Math.floor(Math.random() * (defender.maxDefense - defender.minDefense + 1)) + defender.minDefense;
        const finalDamage = Math.max(1, Math.round((currentAttack * skill.multiplier) - currentDefense));

        const newHp = await updateHP(defender, -finalDamage, "damage");
        
        let message = `üí• ${attacker.name}Ïùò ${skill.name}! ${defender.name}ÏóêÍ≤å **${finalDamage.toFixed(0)} ÌîºÌï¥!**`;
        if (newHp === 0) message += `<br>üíÄ ${defender.name}Ïù¥(Í∞Ä) Ïì∞Îü¨Ï°åÏäµÎãàÎã§!`;
        await logAction(message, "damage");
        return true;
    }
    
    // --- Refactored Apply Heal/Support ---
    async function applyHealOrSupport(caster, target, skillId) {
        const skill = SKILLS[skillId];
        if (!skill) return false;
        
        const isResurrect = skillId === 'resurrect';
        const isHpTransfer = skillId === 'hp_transfer';
        const isMpTransfer = skillId === 'mp_transfer';
        
        // MP/HP Cost Check
        if (caster.mp < skill.mpCost || (isHpTransfer && caster.hp <= skill.hpCost)) {
             const resource = isHpTransfer ? 'HP' : 'MP';
             const cost = isHpTransfer ? skill.hpCost : skill.mpCost;
             const current = isHpTransfer ? caster.hp : caster.mp;
             await logAction(`‚ö†Ô∏è ${caster.name}Ïù¥(Í∞Ä) ${resource}Í∞Ä Î∂ÄÏ°±ÌïòÏó¨ ${skill.name}ÏùÑ(Î•º) ÏãúÏ†ÑÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. (ÌïÑÏöî: ${cost} ${resource}, ÌòÑÏû¨: ${current} ${resource})`, "system");
             return false;
        }
        
        // Consume Resources
        if (skill.mpCost > 0) await updateMP(caster, -skill.mpCost);
        if (skill.hpCost > 0) await updateHP(caster, -skill.hpCost, "damage"); // Self-damage for HP transfer

        // Animation Helper
        const targetToken = document.querySelector(`.character-token[data-char-id="${target.id}"]`);
        if (targetToken) {
            const animationClass = isMpTransfer ? 'heal-animation' : 'heal-animation'; 
            const overlayClass = isMpTransfer ? 'show-heal-overlay' : 'show-heal-overlay';
            targetToken.classList.add(animationClass, overlayClass);
            setTimeout(() => {
                targetToken.classList.remove(animationClass, overlayClass);
            }, 1000);
        }

        let message;
        
        if (isResurrect) {
            // Resurrect: Set HP to 30% of maxHP, set MP to 0. Must be placed (x!=null is checked by eligibility).
            const reviveHp = Math.round(target.maxHp * skill.multiplier);
            await updateDoc(doc(db, 'games', gameId, 'characters', target.id), { 
                hp: reviveHp, 
                mp: 0 
            });
            message = `üëº ${caster.name}Ïùò ${skill.name}! **${target.name}**ÏùÑ(Î•º) **${reviveHp} HP, 0 MP**Î°ú Î∂ÄÌôúÏãúÏº∞ÏäµÎãàÎã§.`;
            await logAction(message, "heal");
        } else if (isHpTransfer) {
            // HP Transfer (Healing)
            const healAmount = Math.max(1, Math.round(caster.minAttack * skill.multiplier));
            const newHp = await updateHP(target, healAmount, "heal");
            message = `üíñ ${caster.name}Ïù¥(Í∞Ä) **${skill.hpCost} HP**Î•º ÏÜåÎ™®ÌïòÏó¨ ${target.name}ÏóêÍ≤å **${healAmount} HP**Î•º Ï†ÑÎã¨ÌñàÏäµÎãàÎã§. (${target.hp} ‚Üí ${newHp})`;
            await logAction(message, "heal");
        } else if (isMpTransfer) {
            // MP Transfer
            const mpAmount = skill.multiplier; // Multiplier holds the fixed MP amount (30)
            const newMp = await updateMP(target, mpAmount);
            message = `üíß ${caster.name}Ïù¥(Í∞Ä) **${skill.mpCost} MP**Î•º ÏÜåÎ™®ÌïòÏó¨ ${target.name}ÏóêÍ≤å **${mpAmount} MP**Î•º Ï†ÑÎã¨ÌñàÏäµÎãàÎã§. (${target.mp} ‚Üí ${newMp})`;
            await logAction(message, "system");
        } else if (skill.type === 'Heal') {
             // Standard Heal
            const baseHeal = Math.floor(Math.random() * (caster.maxAttack - caster.minAttack + 1)) + caster.minAttack;
            const finalHeal = Math.max(1, Math.round(baseHeal * skill.multiplier));
            const newHp = await updateHP(target, finalHeal, "heal");
            message = `‚ú® ${caster.name}Ïùò ${skill.name}! ${target.name}Ïùò **HPÎ•º ${finalHeal.toFixed(0)} ÌöåÎ≥µ!** (${target.hp} ‚Üí ${newHp})`;
            await logAction(message, "heal");
        }
        
        return true;
    }


    async function executeSkill(attacker, target, skillId) {
        const skill = SKILLS[skillId];
        if (!skill) return;
        
        let actionSucceeded = false;

        if (skill.type === 'Heal' || skill.type === 'Support') {
            if (skill.isAoe) {
                const targets = findTargetsInAoe(target.x, target.y, skill.aoeRange, skill.aoeShape, attacker.type, attacker.type);
                if (targets.length > 0) {
                    await logAction(`‚ú® ${attacker.name}Ïù¥(Í∞Ä) ${skill.name}(Ïúº)Î°ú Í¥ëÏó≠ ${skill.type === 'Heal' ? 'ÏπòÏú†' : 'ÏßÄÏõê'}!`, skill.type === 'Heal' ? "heal" : "system");
                    const results = await Promise.all(targets.map(t => applyHealOrSupport(attacker, t, skillId)));
                    actionSucceeded = results.some(r => r);
                } else {
                    await logAction(`‚ú® ${attacker.name}Ïùò ${skill.name}! ÌïòÏßÄÎßå ÎåÄÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§.`, "system");
                }
            } else {
                actionSucceeded = await applyHealOrSupport(attacker, target, skillId);
            }
        } else {
            // Damage Skills (Melee, Ranged)
            if (skill.isAoe) {
                const targets = findTargetsInAoe(target.x, target.y, skill.aoeRange, skill.aoeShape, skill.type, attacker.type);
                if (targets.length > 0) {
                    await logAction(`üî• ${attacker.name}Ïù¥(Í∞Ä) ${skill.name}(Ïúº)Î°ú Í¥ëÏó≠ Í≥µÍ≤©!`, "damage");
                    const results = await Promise.all(targets.map(t => applyDamage(attacker, t, skillId)));
                    actionSucceeded = results.some(r => r);
                } else {
                    await logAction(`üî• ${attacker.name}Ïùò ${skill.name}! ÌïòÏßÄÎßå ÏïÑÎ¨¥ÎèÑ ÎßûÏßÄ ÏïäÏïòÏäµÎãàÎã§.`, "system");
                }
            } else {
                actionSucceeded = await applyDamage(attacker, target, skillId);
            }
        }
        
        if (actionSucceeded) {
            await nextTurn();
        } else {
            render(); // Re-render to show current state/error messages if action failed
        }
    }

    async function undoMove() {
        const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
        if (!selectedCharacter || !preMovePosition) return;
        await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacter.id), { x: preMovePosition.x, y: preMovePosition.y });
        await logAction(`‚Ü©Ô∏è ${selectedCharacter.name}Ïù¥(Í∞Ä) Ïù¥ÎèôÏùÑ Ï∑®ÏÜåÌñàÏäµÎãàÎã§.`, "system");
        turnPhase = 'MOVE';
        render();
    }
    
    // --- Rendering & UI ---
    function showCustomModal(title, message, buttons) {
        document.getElementById('custom-modal-title').textContent = title;
        document.getElementById('custom-modal-message').innerHTML = message;
        const buttonsContainer = document.getElementById('custom-modal-buttons');
        buttonsContainer.innerHTML = '';
        buttons.forEach(btn => {
            const buttonEl = document.createElement('button');
            buttonEl.textContent = btn.text;
            buttonEl.className = `${btn.class} text-white font-bold py-2 px-4 transition`;
            buttonEl.onclick = () => { closeModal('custom-modal'); if (btn.onClick) btn.onClick(); };
            buttonsContainer.appendChild(buttonEl);
        });
        document.getElementById('custom-modal').classList.remove('hidden');
    }

    // --- PC Login Handlers ---
    function openPCLoginModal() {
         const pcChars = characters.filter(c => c.type === 'PC');
         if (pcChars.length === 0) {
             return;
         }

         populatePCLoginSelect(pcChars);
         pcLoginModal.classList.remove('hidden');
         document.getElementById('char-login-password-input').focus();
    }

    function populatePCLoginSelect(pcChars = characters.filter(c => c.type === 'PC')) {
        const selectEl = document.getElementById('char-login-name-select');
        selectEl.innerHTML = pcChars.map(char => `<option value="${char.id}">${char.name} (${char.type})</option>`).join('');
    }

    async function handlePCLogin() {
        const charId = document.getElementById('char-login-name-select').value;
        const password = document.getElementById('char-login-password-input').value;
        const errorP = document.getElementById('char-login-error');
        const targetChar = characters.find(c => c.id === charId);

        errorP.textContent = '';

        if (targetChar && targetChar.password === password) {
            loggedInCharId = charId;
            isAdmin = false;
            closeModal('pc-login-modal');
            updateAuthStatus();
            showCustomModal("Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ", `${targetChar.name}Î°ú Î°úÍ∑∏Ïù∏ÌñàÏäµÎãàÎã§.`, [{text:"ÌôïÏù∏", class:"bg-green-600"}]);
        } else {
            errorP.textContent = 'ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.';
        }
    }
    
    // Function to update all status indicators
    function updateAuthStatus() {
        const char = characters.find(c => c.id === loggedInCharId);
        let authText = 'ÎπÑÎ°úÍ∑∏Ïù∏';
        let authColor = 'var(--text-secondary)';
        let isUserLoggedIn = false;
        
        if (isAdmin) {
            authText = `Í¥ÄÎ¶¨Ïûê (ÌÜ†ÌÅ∞ Ïù¥Îèô: ${isAdminMoveAllowed ? 'ÌóàÏö©' : 'Ï†úÌïú'}, Îßµ Ìé∏Ïßë: ${isMapEditMode ? 'ON' : 'OFF'})`;
            authColor = 'var(--log-admin)';
        } else if (loggedInCharId) {
            authText = `${char ? char.name : 'Unknown PC'} (${char ? char.type : 'PC'})`;
            authColor = 'var(--accent-primary)';
            isUserLoggedIn = true;
        }

        // Update User Info Modal fields
        document.getElementById('user-info-game-id-display').value = gameId || "N/A";
        const authCharSpan = document.getElementById('user-info-auth-char');
        authCharSpan.textContent = authText;
        authCharSpan.style.color = authColor;

        const userInfoLoginBtn = document.getElementById('user-info-login-btn');
        const userInfoLogoutBtn = document.getElementById('user-info-logout-btn');

        if (gameId && characters.some(c => c.type === 'PC') && !isAdmin && !loggedInCharId) {
            userInfoLoginBtn.classList.remove('hidden');
            userInfoLogoutBtn.classList.add('hidden');
        } else if (isAdmin || isUserLoggedIn) {
            userInfoLoginBtn.classList.add('hidden');
            userInfoLogoutBtn.classList.remove('hidden');
        } else {
            userInfoLoginBtn.classList.add('hidden');
            userInfoLogoutBtn.classList.add('hidden');
        }

        // Bind listeners for User Info Modal buttons
        userInfoLoginBtn.onclick = openPCLoginModal;
        userInfoLogoutBtn.onclick = handleLogout;
    }
    
    function handleLogout() {
        loggedInCharId = null;
        isAdmin = false;
        isMapEditMode = false;
        updateAuthStatus();
        closeModal('user-info-modal'); // Close info modal after logout
        render();
        closeModal('map-edit-modal');
    }
    // --- End PC Login Handlers ---

    function initializeBoard() {
        if (isBoardInitialized) return;
        gameBoard.innerHTML = '';
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                gameBoard.appendChild(cell);
            }
        }
        isBoardInitialized = true;
    }

    function highlightRange(char, skillId) {
        document.querySelectorAll('.combat-range').forEach(cell => cell.classList.remove('combat-range', 'attack-range-move', 'attack-range-skill', 'heal-range-skill'));
        if (!char || char.x === null || !SKILLS[skillId]) return;

        const skill = SKILLS[skillId];
        const range = skill.range;
        const size = char.size || 1;
        
        const isMove = skill.category === 'Utility'; // Check category for utility skills
        const isAttack = skill.category === 'Attack';
        const isHealOrSupport = skill.category === 'Heal' || skill.category === 'Support';
        
        const shape = skill.rangeShape || 'diamond';
        const validCells = new Set();
        const invalidMoveCells = new Set(); // Cells occupied or blocked by obstacle

        if (isMove) {
            // Movement range
            const originX = char.x, originY = char.y;
            for (let dy = -range; dy <= range; dy++) for (let dx = -range; dx <= range; dx++) {
                if (Math.abs(dx) + Math.abs(dy) <= range) {
                    const targetX = originX + dx, targetY = originY + dy;
                    const cellKey = `${targetX},${targetY}`;

                    if (targetX >= 0 && targetX < BOARD_SIZE && targetY >= 0 && targetY < BOARD_SIZE) {
                        if (canPlaceCharacter(char, targetX, targetY)) {
                            validCells.add(cellKey);
                        } else {
                            invalidMoveCells.add(cellKey);
                        }
                    }
                }
            }
        } else if (isAttack || isHealOrSupport) {
             // Action range
            for (let ex = 0; ex < size; ex++) for (let ey = 0; ey < size; ey++) {
                const originX = char.x + ex, originY = char.y + ey;
                for (let dy = -range; dy <= range; dy++) for (let dx = -range; dx <= range; dx++) {
                    let inShape = (shape === 'diamond' && Math.abs(dx) + Math.abs(dy) <= range) ||
                                  (shape === 'square' && Math.abs(dx) <= range && Math.abs(dy) <= range) ||
                                  (shape === 'cross' && (dx === 0 || dy === 0));
                    if (inShape) {
                        const targetX = originX + dx, targetY = originY + dy;
                        if (targetX >= 0 && targetX < BOARD_SIZE && targetY >= 0 && targetY < BOARD_SIZE) validCells.add(`${targetX},${targetY}`);
                    }
                }
            }
            if (!skill.isAoe) {
                for (let ex = 0; ex < size; ex++) for (let ey = 0; ey < size; ey++) validCells.delete(`${char.x + ex},${char.y + ey}`);
            }
        }

        const className = isMove ? 'attack-range-move' : (isHealOrSupport ? 'heal-range-skill' : 'attack-range-skill');
        validCells.forEach(coord => {
            const [x, y] = coord.split(',');
            document.querySelector(`.cell[data-x='${x}'][data-y='${y}']`)?.classList.add('combat-range', className);
        });
    }
    
    function renderCharacterSelectionOverlay() {
        const selectionList = document.getElementById('selection-list');
        selectionList.innerHTML = characters.length === 0 ? `<div class="text-white/70 text-lg w-full text-center p-4">Ïù∏Ï¶ù Ï§ë...</div>` : '';
        if (characters.length === 0) return;
        
        const renderCard = (char) => {
            const isSelected = char.id === selectedCharacterId, isPlaced = char.x !== null, isDead = char.hp <= 0, isEnemy = char.type === 'ENEMY';
            const canBeDragged = (!isEnemy && (gameState === 'PREPARATION' && !isDead)) || (!isPlaced && !isDead) || (isAdmin && isAdminMoveAllowed);
            
            const charCard = document.createElement('div');
            charCard.className = `char-card-item ${isSelected ? 'selected' : ''} ${isEnemy ? 'enemy-card' : ''}`;
            charCard.dataset.charId = char.id;
            charCard.draggable = canBeDragged;
            
            if (char.imageUrl) charCard.style.backgroundImage = `url(${char.imageUrl})`;
            else charCard.innerHTML = `<span class="card-placeholder font-title">${char.name.charAt(0)}</span>`;
            if (isDead) { charCard.style.filter = 'grayscale(100%) opacity(0.7)'; charCard.draggable = false; }
            
            const infoContainer = document.createElement('div');
            infoContainer.className = 'char-card-info';
            infoContainer.innerHTML = `
                <div class="text-sm font-light ${isEnemy ? 'text-red-300' : 'text-gray-400'}">ÏàúÏÑú: ${char.turnOrder} (${char.type})</div>
                <div class="font-bold">${char.name} <span class="text-red-400 text-sm">${isDead ? '(ÏÇ¨Îßù)' : ''}</span></div>
                <div class="flex justify-between items-center text-sm">
                    <span class="text-white/80">${isPlaced ? `(${char.x}, ${char.y})` : 'ÎØ∏Î∞∞Ïπò (ÎìúÎûòÍ∑∏)'}</span>
                    <button class="details-btn">ÏÉÅÏÑ∏</button>
                </div>`;
            
            infoContainer.querySelector('button').onclick = (e) => { e.stopPropagation(); openProfileModal(char); };
            charCard.appendChild(infoContainer);
            charCard.onclick = () => { if (isPlaced && !isDead) { selectedCharacterId = char.id; if(gameState === 'STARTED') { turnPhase = 'MOVE'; selectedSkill = 'move'; preMovePosition = { x: char.x, y: char.y }; } render(); } };
            if (canBeDragged) charCard.ondragstart = (e) => e.dataTransfer.setData('text/plain', char.id);
            return charCard;
        };

        const pcContainer = document.createElement('div');
        pcContainer.className = 'flex gap-4';
        characters.filter(c => c.type === 'PC').forEach(char => pcContainer.appendChild(renderCard(char)));
        selectionList.appendChild(pcContainer);

        const enemyContainer = document.createElement('div');
        enemyContainer.className = 'flex gap-4 pl-4 border-l-2 border-red-800/50';
        characters.filter(c => c.type === 'ENEMY').forEach(char => enemyContainer.appendChild(renderCard(char)));
        selectionList.appendChild(enemyContainer);
    }
    
    function renderSkillButtons(selectedChar, isCurrentTurn) {
        const currentTurnChar = characters[currentTurnIndex];
        const canControlSelectedChar = selectedChar && canControlCharacter(selectedChar.id);
        const isTurnCharacter = selectedChar && currentTurnChar && selectedChar.id === currentTurnChar.id;

        skillControls.innerHTML = '';
         if (gameState === 'PREPARATION') {
            skillControls.innerHTML = `<h3 class="text-lg font-bold mb-2 text-yellow-400">Ï§ÄÎπÑ Îã®Í≥Ñ</h3><p class="text-sm text-gray-400">Ï∫êÎ¶≠ÌÑ∞Î•º ÎìúÎûòÍ∑∏ÌïòÍ±∞ÎÇò ÌÅ¥Î¶≠ÌïòÏó¨ Î∞∞ÏπòÌïòÏÑ∏Ïöî.</p>`;
            return;
        }

        if (!selectedChar || !canControlSelectedChar) { 
            if (selectedChar) {
                skillControls.innerHTML = `<p class="text-sm text-gray-400">ÌòÑÏû¨ ${selectedChar.name}Ïùò ÌÑ¥Ïù¥ ÏïÑÎãàÍ±∞ÎÇò, Ï†úÏñ¥ Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.</p>`;
            } else {
                 skillControls.innerHTML = `<p class="text-sm text-gray-400">Ï∫êÎ¶≠ÌÑ∞Î•º ÏÑ†ÌÉùÌïòÎ©¥ Ïä§ÌÇ¨Ïù¥ ÌëúÏãúÎê©ÎãàÎã§.</p>`; 
            }
            return; 
        }
        
        if (selectedChar.hp <= 0 || selectedChar.x === null) { 
            skillControls.innerHTML = `<p class="text-sm text-gray-500">${selectedChar.hp <= 0 ? 'ÏÇ¨ÎßùÌï®' : 'ÎØ∏Î∞∞Ïπò ÏÉÅÌÉú'}</p>`; 
            return; 
        }

        let html = `<h3 class="text-lg font-bold mb-2 ${selectedChar.type === 'ENEMY' ? 'text-red-400' : 'text-green-400'}">${selectedChar.name} ÌñâÎèô</h3>`;

        // Display current MP
        html += `<p class="text-sm font-semibold text-blue-400 mb-3">MP: ${selectedChar.mp}/${selectedChar.maxMp}</p>`;

        if (isTurnCharacter) {
            if (turnPhase === 'MOVE') {
                html += `<p class="text-sm text-gray-400">Ïù¥ÎèôÌï† ÏúÑÏπòÎ•º ÏÑ†ÌÉùÌïòÍ±∞ÎÇò, Ï∫êÎ¶≠ÌÑ∞ ÏúÑÏùò '‚ñº'Î•º ÌÅ¥Î¶≠ÌïòÏó¨ Ïù¥ÎèôÏùÑ Í±¥ÎÑàÎõ∞ÏÑ∏Ïöî.</p>`;
            } else { 
                html += `<div class="flex flex-wrap gap-2">`;
                
                // Separate skills by category for display
                const categorizedSkills = { Attack: [], Support: [], Heal: [], Utility: [] };
                selectedChar.skills.forEach(id => {
                    const skill = SKILLS[id];
                    if (skill && skill.category) {
                        if (categorizedSkills[skill.category]) {
                            categorizedSkills[skill.category].push(skill);
                        }
                    }
                });

                // Render Action Skills first (Attack, Heal, Support)
                ['Attack', 'Heal', 'Support', 'Utility'].forEach(category => {
                    if (categorizedSkills[category].length > 0) {
                        // Add a separator for better visual grouping (optional)
                        // if (category !== 'Attack' && category !== 'Utility') { html += `<hr class="w-full my-1 border-gray-700/50">`; }

                        categorizedSkills[category].forEach(skill => {
                            const isMoveSkill = skill.id === 'move' && skill.category === 'Utility';
                            
                            // Only show Utility skills (like Fast Move, or specific ranged movement) in ACTION phase if explicitly added by user, and not the default 'move' skill which is handled by the board highlight during MOVE phase.
                            // If we are in the ACTION phase, we allow utility spells, including specific move options.
                            if (isMoveSkill && category === 'Utility' && turnPhase === 'ACTION') {
                                return; // Skip default move in ACTION buttons
                            }
                            
                            const isActionSkill = category !== 'Utility' || isMoveSkill;

                            const isHealSupport = category === 'Heal' || category === 'Support';
                            const ringColor = isHealSupport ? 'ring-green-400' : 'ring-red-400';
                            
                            const canUse = selectedChar.mp >= skill.mpCost && (skill.hpCost === undefined || selectedChar.hp > skill.hpCost);
                            const disabledClass = canUse ? '' : 'opacity-50 cursor-not-allowed';
                            
                            let costText = "";
                            if (skill.mpCost > 0) costText += ` MP ${skill.mpCost}`;
                            if (skill.hpCost > 0) costText += ` HP ${skill.hpCost}`;
                            if (costText) costText = `[${costText.trim()}]`;

                            html += `<button data-skill-id="${skill.id}" data-category="${skill.category}" class="skill-btn ${selectedSkill === skill.id ? `ring-2 ${ringColor}` : ''} bg-gray-700 hover:bg-gray-600 text-white p-2 flex items-center flex-col text-xs font-semibold ${disabledClass}" ${canUse ? '' : 'disabled'}>
                                ${skill.icon} ${skill.name}
                                <span class="text-gray-400 text-xs">${costText}</span>
                                </button>`;
                        });
                    }
                });
                
                html += `</div><button id="undo-move-btn" class="w-full mt-2 bg-gray-500 hover:bg-gray-600 text-white p-2">‚Ü©Ô∏è Ïù¥Îèô Ï∑®ÏÜå</button>`;
            }

            html += `<button id="end-turn-btn" class="w-full mt-4 bg-yellow-600 hover:bg-yellow-700 text-white p-2 font-bold">ÌÑ¥ Ï¢ÖÎ£å</button>`;
            
            if (isAdmin) {
                html += `<p class="text-sm text-purple-400 mt-2">üëë Í¥ÄÎ¶¨Ïûê Ï†úÏñ¥ Ï§ë</p>`;
            }

        } else if (isAdmin) {
            html += `<p class="text-sm text-purple-400 mt-4">Í¥ÄÎ¶¨Ïûê Î™®Îìú: ÌÑ¥ Ï†úÏïΩ ÏóÜÏùå</p>`;
        } else {
            html += `<p class="text-sm text-gray-400 mt-4">${selectedChar.name}Ïùò Ï∞®Î°ÄÍ∞Ä ÏïÑÎãôÎãàÎã§.</p>`;
        }
        
        skillControls.innerHTML = html;
        document.getElementById('end-turn-btn')?.addEventListener('click', nextTurn);
        document.getElementById('undo-move-btn')?.addEventListener('click', undoMove);
        document.querySelectorAll('.skill-btn').forEach(btn => btn.onclick = (e) => { 
            selectedSkill = e.currentTarget.dataset.skillId; 
            // If it's a utility skill, we must switch to MOVE phase to highlight the range correctly.
            if (e.currentTarget.dataset.category === 'Utility') {
                // Check if this Utility skill allows movement (range > 0)
                const skillId = e.currentTarget.dataset.skillId;
                if (SKILLS[skillId]?.range > 0) {
                    turnPhase = 'MOVE';
                }
            } else {
                turnPhase = 'ACTION';
            }
            render(); 
        });
    }
    
    function updateCharacterList() {
        const listContent = document.getElementById('char-list-content');
        listContent.innerHTML = '';
        
        const remainingPC = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null).length;
        const remainingEnemy = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.x !== null).length;

        // Use the new class for styling
        document.getElementById('pc-count').textContent = remainingPC;
        document.getElementById('enemy-count').textContent = remainingEnemy;
        document.getElementById('pc-count').classList.add('summary-count');
        document.getElementById('enemy-count').classList.add('summary-count');

        if (!gameId || characters.length === 0) { listContent.innerHTML = `<p class="text-sm text-gray-400">${!gameId ? 'Í≤åÏûÑÏóê Ï∞∏Ïó¨Ìï¥Ï£ºÏÑ∏Ïöî...' : 'Ï∫êÎ¶≠ÌÑ∞ Î°úÎî© Ï§ë...'}</p>`; return; }
        
        const currentTurnChar = characters[currentTurnIndex];
        characters.forEach(char => {
            const isTurnChar = currentTurnChar && char.id === currentTurnChar.id && gameState === 'STARTED';
            const charItem = document.createElement('div');
            charItem.className = `p-2 rounded-md flex flex-col cursor-pointer ${char.id === selectedCharacterId ? 'ring-2 ring-green-400' : 'hover:bg-gray-800'} ${isTurnChar && char.x !== null && char.hp > 0 ? 'turn-highlight' : ''}`;
            
            let statusColor = char.hp <= 0 ? 'text-gray-500' : (char.type === 'ENEMY' ? 'text-red-400' : 'text-gray-300');
            if (isTurnChar && char.x !== null && char.hp > 0) statusColor = 'text-yellow-400';
            
            charItem.innerHTML = `
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-2">
                        <img src="${char.imageUrl || ''}" onerror="this.src='https://placehold.co/32x32/1f2937/a0aec0?text=${char.name.charAt(0)}'" class="w-8 h-8 rounded-full object-cover">
                        <span class="font-semibold truncate">${char.name}</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-xs ${statusColor}">${char.hp <= 0 ? 'ÏÇ¨Îßù' : (char.x !== null ? `HP: ${char.hp}/${char.maxHp}` : 'ÎØ∏Î∞∞Ïπò')}</span>
                        ${isAdmin ? `<button data-char-id="${char.id}" class="delete-char-btn text-red-500 hover:text-red-400 text-xs ml-2 p-1 rounded-sm border border-red-500 hover:border-red-400">ÏÇ≠Ï†ú</button>` : ''}
                    </div>
                </div>
            `;
            // REMOVE HP/MP BARS HERE
            charItem.onclick = () => { if (char.hp > 0 || isAdmin) { selectedCharacterId = char.id; if(gameState === 'STARTED'){ turnPhase = 'MOVE'; selectedSkill = 'move'; preMovePosition = { x: char.x, y: char.y }; } render(); } };
            listContent.appendChild(charItem);
        });

        if (isAdmin) {
            document.querySelectorAll('.delete-char-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const charIdToDelete = e.currentTarget.dataset.charId;
                    const charName = characters.find(c => c.id === charIdToDelete)?.name || 'Unknown Character';
                    showCustomModal("Ï∫êÎ¶≠ÌÑ∞ ÏÇ≠Ï†ú ÌôïÏù∏", `Ï†ïÎßêÎ°ú **${charName}**ÏùÑ(Î•º) ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå? (ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§!)`, [
                        { text: "Ï∑®ÏÜå", class: "bg-gray-600" },
                        { text: "ÏÇ≠Ï†ú", class: "bg-red-600", onClick: () => deleteCharacter(charIdToDelete, charName) }
                    ]);
                };
            });
        }
    }

    async function deleteCharacter(charId, charName) {
        if (gameId) {
            await deleteDoc(doc(db, 'games', gameId, 'characters', charId));
            await logAction(`üî• Í¥ÄÎ¶¨ÏûêÍ∞Ä **${charName}** Ï∫êÎ¶≠ÌÑ∞Î•º ÏÇ≠Ï†úÌñàÏäµÎãàÎã§.`, "admin");
            // Reset selected character if it was the one deleted
            if (selectedCharacterId === charId) selectedCharacterId = null;
            if (loggedInCharId === charId) handleLogout();
        }
    }
    
    async function deleteSkill(skillId, skillName) { // NEW: Delete Skill Function
         if (!gameId || !isAdmin) return;
         
         // 1. Remove skill from global skills map
         const newSkills = { ...SKILLS };
         delete newSkills[skillId];
         
         // 2. Remove skill from all characters that possess it
         const batch = writeBatch(db);
         characters.forEach(char => {
             if (char.skills.includes(skillId)) {
                 const newCharSkills = char.skills.filter(s => s !== skillId);
                 const charRef = doc(db, 'games', gameId, 'characters', char.id);
                 batch.update(charRef, { skills: newCharSkills });
             }
         });
         
         // 3. Update global skills map
         batch.set(doc(db, 'games', gameId), { skills: newSkills }, { merge: true });
         
         await batch.commit();
         await logAction(`üî• Í¥ÄÎ¶¨ÏûêÍ∞Ä **${skillName}** Ïä§ÌÇ¨ÏùÑ ÏÇ≠Ï†úÌñàÏäµÎãàÎã§.`, "admin");
         
         if (selectedSkill === skillId) selectedSkill = null;
         openAdminModal(); // Re-open admin modal to refresh list
    }


    function renderLogs(logs) {
        const logList = document.getElementById('game-log-list');
        logList.innerHTML = logs.map(log => {
            const timeString = log.timestamp ? `[${log.timestamp.toDate().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' })}] ` : '';
            return `<li class="log-${log.type}">${timeString}${log.message}</li>`;
        }).join('') || `<li class="log-system">ÏïÑÏßÅ Í∏∞Î°ùÎêú ÌñâÎèôÏù¥ ÏóÜÏäµÎãàÎã§.</li>`;
    }
    
    function render() {
        if (!isBoardInitialized) initializeBoard();
        
        document.querySelectorAll('.cell').forEach(cell => { 
            cell.innerHTML = ''; 
            cell.classList.remove('enemy-threat-range', 'tile-obstacle', 'tile-damage'); 
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            const tile = boardTiles[`${x},${y}`];
            if (tile && tile.type !== 'normal') {
                cell.classList.add(`tile-${tile.type}`);
            }
        });

        const currentTurnChar = characters.length > 0 ? characters[currentTurnIndex] : null;
        updateAuthStatus();

        characters.filter(char => char.x !== null).forEach(char => {
            const cell = gameBoard.querySelector(`.cell[data-x='${char.x}'][data-y='${char.y}']`);
            if (cell) {
                const token = document.createElement('div');
                token.className = 'character-token';
                if (char.type === 'ENEMY') token.classList.add('enemy-token');
                
                token.style.width = `${char.size * 100}%`;
                token.style.height = `${char.size * 100}%`;

                if (char.hp <= 0) token.style.filter = 'grayscale(100%) opacity(0.5)';
                if(char.imageUrl) token.style.backgroundImage = `url(${char.imageUrl})`; else token.innerHTML = `<span class="token-placeholder font-title">${char.name.charAt(0)}</span>`;
                token.dataset.charId = char.id;
                
                const hpPercent = (char.hp / char.maxHp) * 100;
                const mpPercent = (char.mp / char.maxMp) * 100;

                // HP/MP Bars
                token.innerHTML += `
                    <div class="hp-mp-bar-container">
                        <div class="hp-bar"><div class="hp-fill" style="width: ${hpPercent}%;"></div></div>
                        <div class="mp-bar"><div class="mp-fill" style="width: ${mpPercent}%;"></div></div>
                    </div>
                `;
                
                // --- Turn Marker Insertion (for skipping move) ---
                if (gameState === 'STARTED' && currentTurnChar && char.id === currentTurnChar.id && char.hp > 0) {
                     const marker = document.createElement('div');
                     marker.className = 'turn-marker';
                     marker.innerHTML = '‚ñº';
                     marker.dataset.charId = char.id; // Add ID for click handling
                     marker.onclick = (e) => {
                         e.stopPropagation();
                         const charId = e.currentTarget.dataset.charId;
                         // Check if the current user has control over this char
                         if (canControlCharacter(charId) && turnPhase === 'MOVE') {
                             selectedCharacterId = charId; // Ensure selected
                             turnPhase = 'ACTION'; // Skip move phase
                             selectedSkill = null;
                             preMovePosition = { x: char.x, y: char.y };
                             logAction(`‚è© ${char.name}Ïù¥(Í∞Ä) Ïù¥Îèô Îã®Í≥ÑÎ•º Í±¥ÎÑàÎõ∞ÏóàÏäµÎãàÎã§.`, "system");
                             render();
                         }
                     };
                     token.appendChild(marker);
                }
                // --- End Turn Marker Insertion ---
                
                if (char.id === selectedCharacterId) token.classList.add('selected-character');
                cell.appendChild(token);
            }
        });

        if (gameState === 'PREPARATION') {
            turnStatus.textContent = `Ï§ÄÎπÑ Îã®Í≥Ñ (ÎùºÏö¥Îìú ${round})`;
            turnStatus.style.color = 'var(--text-secondary)';
        } else {
             turnStatus.textContent = currentTurnChar ? `Round ${round} - ${currentTurnChar.name}` : (gameId ? "Î∞∞Ïπò ÎåÄÍ∏∞ Ï§ë..." : "Í≤åÏûÑ ÏãúÏûë ÎåÄÍ∏∞ Ï§ë...");
            if(currentTurnChar) turnStatus.style.color = currentTurnChar.type === 'ENEMY' ? '#f87171' : '#34d399';
        }

        // Apply new stylish class to turn status box
        document.getElementById('turn-status').classList.add('stylish-turn-box');
        
        const selectedChar = characters.find(c => c.id === selectedCharacterId);
        const isMyTurn = selectedChar && currentTurnChar && selectedChar.id === currentTurnChar.id;

        if (gameState === 'STARTED') {
            const canControl = isAdmin || (isMyTurn && selectedChar?.id === loggedInCharId);
            // NEW: Determine effective skill for range highlighting. If in MOVE phase, use 'move' or the selected Utility skill.
            let effectiveSkillId = 'move';
            // Check for character-specific move range
            if (selectedChar && selectedChar.moveRange !== undefined && SKILLS['move']) {
                 SKILLS['move'].range = selectedChar.moveRange;
            }
            
            if (turnPhase === 'MOVE' && selectedSkill && SKILLS[selectedSkill]?.category === 'Utility') {
                effectiveSkillId = selectedSkill;
            } else if (turnPhase === 'ACTION' && selectedSkill) {
                effectiveSkillId = selectedSkill;
            }
            
            if (canControl && selectedChar && effectiveSkillId) {
                highlightRange(selectedChar, effectiveSkillId);
            } else {
                highlightRange(null, null);
            }
        } else {
            highlightRange(null, null);
        }
        
        renderSkillButtons(selectedChar, isMyTurn);
        updateCharacterList();
        renderCharacterSelectionOverlay();
    }

    // NEW: Function to remove character placement
    async function removeCharacterPlacement(charId, charName) {
        if (gameId) {
            await updateDoc(doc(db, 'games', gameId, 'characters', charId), { x: null, y: null });
            await logAction(`‚Ü©Ô∏è ${charName}Ïù¥(Í∞Ä) Î≥¥ÎìúÏóêÏÑú Î∞∞Ïπò Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§.`, "admin");
            if (selectedCharacterId === charId) selectedCharacterId = null;
            closeModal('profile-modal');
            render();
        }
    }


    window.openProfileModal = (charId) => openProfileModal(characters.find(c => c.id === charId));
    
    function openProfileModal(character, editMode = false) {
        if (!character) return;
        const contentContainer = profileModal.querySelector('#modal-content');
        const isEnemy = character.type === 'ENEMY';
        
        // Authorization Check for action buttons in profile modal
        const canUnplace = isAdmin || (loggedInCharId === character.id && character.type === 'PC' && gameState === 'PREPARATION');
        
        if (editMode) {
            // Admin Edit Mode
             const skillOptions = Object.values(SKILLS); // Include all skills now
            const skillSelects = [1, 2, 3, 4, 5].map(index => { // Increased skill slots for management
                const currentSkill = character.skills?.[index - 1] || 'none';
                return `<div><label class="text-sm text-gray-400">Ïä§ÌÇ¨ ${index}</label><select id="edit-skill-${index}" class="form-input mt-1"><option value="none">-- ÏóÜÏùå --</option>${skillOptions.map(skill => `<option value="${skill.id}" ${skill.id === currentSkill ? 'selected' : ''}>${skill.name} (${skill.category})</option>`).join('')}</select></div>`;
            }).join('');
            
            const currentMoveRange = character.moveRange !== undefined 
                ? character.moveRange 
                : SKILLS['move']?.range || 2;
            
            contentContainer.innerHTML = `<div class="profile-modal-container rounded-lg ${isEnemy ? 'enemy-profile' : ''}" style="grid-template-columns: 1fr;">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-6"><h3 class="text-2xl font-bold font-title text-accent-primary">ÏàòÏ†ï: ${character.name}</h3><button id="close-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button></div>
                    <div class="space-y-4 max-h-[70vh] overflow-y-auto pr-4">
                        <div><label class="text-gray-400">Ïù¥Î¶Ñ</label><input id="edit-name" class="form-input mt-1" value="${character.name}"></div>
                        <div><label class="text-gray-400">Ïù¥ÎØ∏ÏßÄ URL</label><input id="edit-image-url" class="form-input mt-1" value="${character.imageUrl || ''}"></div>
                        ${character.type === 'PC' ? `<div><label class="text-gray-400">PC ÎπÑÎ∞ÄÎ≤àÌò∏</label><input id="edit-password" type="text" class="form-input mt-1" value="${character.password || DEFAULT_PC_PASSWORD}"></div>` : ''}
                        <div class="grid grid-cols-3 gap-4">
                            <div><label class="text-gray-400">HP</label><input id="edit-hp" type="number" class="form-input mt-1" value="${character.hp}"></div><div><label class="text-gray-400">ÏµúÎåÄ HP</label><input id="edit-max-hp" type="number" class="form-input mt-1" value="${character.maxHp}"></div>
                            <div><label class="text-gray-400">MP</label><input id="edit-mp" type="number" class="form-input mt-1" value="${character.mp}"></div><div><label class="text-gray-400">ÏµúÎåÄ MP</label><input id="edit-max-mp" type="number" class="form-input mt-1" value="${character.maxMp}"></div>
                            <div><label class="text-gray-400">ÏµúÏÜå Í≥µÍ≤©Î†•</label><input id="edit-min-attack" type="number" class="form-input mt-1" value="${character.minAttack}"></div><div><label class="text-gray-400">ÏµúÎåÄ Í≥µÍ≤©Î†•</label><input id="edit-max-attack" type="number" class="form-input mt-1" value="${character.maxAttack}"></div>
                            <div><label class="text-gray-400">ÏµúÏÜå Î∞©Ïñ¥Î†•</label><input id="edit-min-defense" type="number" class="form-input mt-1" value="${character.minDefense}"></div><div><label class="text-gray-400">ÏµúÎåÄ Î∞©Ïñ¥Î†•</label><input id="edit-max-defense" type="number" class="form-input mt-1" value="${character.maxDefense}"></div>
                            <div><label class="text-gray-400">ÌÅ¨Í∏∞ (Ïòà: 1, 2)</label><input id="edit-size" type="number" class="form-input mt-1" value="${character.size || 1}"></div>
                            <div><label class="text-gray-400">ÌÑ¥ ÏàúÏÑú</label><input id="edit-order" type="number" class="form-input mt-1" value="${character.turnOrder}"></div>
                        </div>
                        <h4 class="text-lg font-bold text-gray-300 pt-4">Ïä§ÌÇ¨ ÏÑ†ÌÉù</h4>
                        <div class="grid grid-cols-3 gap-4">${skillSelects}</div>
                        ${character.skills.includes('move') ? 
                            `
                            <h4 class="text-lg font-bold text-gray-300 pt-4 border-t border-gray-700/50">ÌñâÎèôÎ†• Ï°∞Ï†ï</h4>
                            <div>
                                <label class="text-gray-400">Ïù¥ÎèôÎ†• ('move' Ïä§ÌÇ¨ Î≤îÏúÑ)</label>
                                <input id="edit-move-range" type="number" class="form-input mt-1" value="${currentMoveRange}">
                            </div>
                            ` : ''}
                    </div>
                    <div class="mt-8 flex gap-4 flex-shrink-0">
                       <button id="save-changes-btn" class="w-full bg-green-600 font-bold py-3">Ï†ÄÏû•</button><button id="cancel-edit-btn" class="w-full bg-gray-600 font-bold py-3">Ï∑®ÏÜå</button>
                    </div>
                </div>
            </div>`;
            
            document.getElementById('save-changes-btn').onclick = async () => {
                const updates = { 
                    name: document.getElementById('edit-name').value, 
                    imageUrl: document.getElementById('edit-image-url').value.trim(), 
                    hp: parseInt(document.getElementById('edit-hp').value), 
                    maxHp: parseInt(document.getElementById('edit-max-hp').value), 
                    mp: parseInt(document.getElementById('edit-mp').value), 
                    maxMp: parseInt(document.getElementById('edit-max-mp').value), 
                    minAttack: parseInt(document.getElementById('edit-min-attack').value),
                    maxAttack: parseInt(document.getElementById('edit-max-attack').value),
                    minDefense: parseInt(document.getElementById('edit-min-defense').value),
                    maxDefense: parseInt(document.getElementById('edit-max-defense').value),
                    size: parseInt(document.getElementById('edit-size').value) || 1,
                    turnOrder: parseInt(document.getElementById('edit-order').value) || 99, 
                    skills: [
                        document.getElementById('edit-skill-1').value, 
                        document.getElementById('edit-skill-2').value, 
                        document.getElementById('edit-skill-3').value,
                        document.getElementById('edit-skill-4').value,
                        document.getElementById('edit-skill-5').value
                    ].filter(s => s && s !== 'none') 
                };
                if (character.type === 'PC') updates.password = document.getElementById('edit-password').value;

                // NEW: Update 'move' skill range for this specific character if changed.
                if (character.skills.includes('move')) {
                    const newMoveRange = parseInt(document.getElementById('edit-move-range').value) || 2;
                    updates.moveRange = newMoveRange;
                }
                
                if (gameId) await updateDoc(doc(db, 'games', gameId, 'characters', character.id), updates);
                openProfileModal({...character, ...updates}, false);
            };
            document.getElementById('cancel-edit-btn').onclick = () => openProfileModal(character, false);
        } else {
            // View mode HTML
            const statIcon = (type) => ({
                hp: `<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path></svg>`,
                defense: `<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-3z" /></svg>`,
                mp: `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 10v2h14v-2H5z"></path></svg>`,
            }[type] || '');
            const attackIconSvg = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 12H4M17 12h3"></path></svg>`;
            const sizeIconSvg = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`;
            const moveIconSvg = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>`;


            const buildStat = (type, label, value) => {
                let iconHtml = statIcon(type);
                if (type === 'attack') iconHtml = attackIconSvg;
                if (type === 'size') iconHtml = sizeIconSvg;
                if (type === 'move') iconHtml = moveIconSvg;
                return `<div class="stat-item">${iconHtml}<div><div class="value">${value}</div><div class="label">${label}</div></div></div>`;
            }
            
            // Get effective move range (check if moveRange is set on character, otherwise fall back to global move skill range)
            const effectiveMoveRange = character.moveRange !== undefined 
                ? character.moveRange 
                : SKILLS['move']?.range || 2;


            contentContainer.innerHTML = `<div class="profile-modal-container rounded-lg ${isEnemy ? 'enemy-profile' : ''}">
                <button id="close-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button>
                <div class="profile-char-image" style="background-image: url('${character.imageUrl || `https://placehold.co/400x600/1a1a1a/444444?text=${character.name.charAt(0)}`}')"></div>
                <div class="profile-stats-panel">
                    <div class="profile-content-scroll">
                        <div>
                            <h2 class="profile-char-name font-title">${character.name}</h2>
                            <p class="profile-char-type">${character.type}</p>
                            <div class="profile-stats-grid">
                                ${buildStat('hp', 'ÏÉùÎ™ÖÎ†•', `${character.hp} / ${character.maxHp}`)}
                                ${buildStat('mp', 'ÎßàÎÇò', `${character.mp} / ${character.maxMp}`)}
                                ${buildStat('attack', 'Í≥µÍ≤©Î†•', `${character.minAttack} - ${character.maxAttack}`)}
                                ${buildStat('defense', 'Î∞©Ïñ¥Î†•', `${character.minDefense} - ${character.maxDefense}`)}
                                ${buildStat('move', 'Ïù¥ÎèôÎ†•', `${effectiveMoveRange} Ïπ∏`)}
                                ${buildStat('size', 'ÌÅ¨Í∏∞', `${character.size}x${character.size}`)}
                            </div>
                        </div>
                        <div class="mt-6">
                            <h3 class="text-xl font-bold mb-3">Î≥¥Ïú† Ïä§ÌÇ¨</h3>
                            <div class="space-y-2">
                                ${character.skills.map(id => SKILLS[id]).filter(Boolean).map(s => {
                                    let costText = "";
                                    if (s.mpCost > 0) costText += `${s.mpCost} MP `;
                                    if (s.hpCost > 0) costText += `${s.hpCost} HP `;
                                    return `<div class="p-3 bg-gray-800/50 rounded-md flex items-center gap-3">
                                        <span class="text-2xl">${s.icon}</span>
                                        <div>
                                            <strong>${s.name} <span class="text-xs text-gray-500">(${s.category})</span></strong>
                                            <small class="block text-gray-400">
                                                ${s.isAoe ? `Í¥ëÏó≠(Î≤îÏúÑ: ${s.aoeRange})` : `Îã®Ïùº`}, ÏÇ¨Í±∞Î¶¨: ${s.range}
                                                ${costText ? `| ÎπÑÏö©: ${costText}` : ''}
                                            </small>
                                        </div>
                                    </div>`;
                                }).join('') || '<p class="text-gray-500">Î≥¥Ïú† Ïä§ÌÇ¨Ïù¥ ÏóÜÏäµÎãàÎã§.</p>'}
                            </div>
                        </div>
                    </div>
                    <div class="mt-auto pt-4 flex-shrink-0 space-y-3">
                       <button id="edit-char-btn" class="w-full bg-gray-600 hover:bg-gray-700 font-bold py-3 px-4">Ï∫êÎ¶≠ÌÑ∞ ÏàòÏ†ï</button>
                       ${(character.x !== null && canUnplace) ? `<button id="unplace-char-btn" class="w-full bg-red-700 hover:bg-red-600 font-bold py-3 px-4">Î≥¥ÎìúÏóêÏÑú Î∞∞Ïπò Ìï¥Ï†ú</button>` : ''}
                    </div>
                </div>
            </div>`;
            
            document.getElementById('edit-char-btn').onclick = () => {
                if (isAdmin) {
                    openProfileModal(character, true);
                } else {
                    showCustomModal("Í∂åÌïú Î∂ÄÏ°±", "Ï∫êÎ¶≠ÌÑ∞ Ï†ïÎ≥¥ ÏàòÏ†ïÏùÄ Í¥ÄÎ¶¨ÏûêÎßå Í∞ÄÎä•Ìï©ÎãàÎã§.", [{text:"ÌôïÏù∏", class:"bg-red-600"}]);
                }
            };
            
            const unplaceBtn = document.getElementById('unplace-char-btn');
            if (unplaceBtn) {
                 unplaceBtn.onclick = () => {
                    showCustomModal("Î∞∞Ïπò Ìï¥Ï†ú ÌôïÏù∏", `${character.name}ÏùÑ(Î•º) Î≥¥ÎìúÏóêÏÑú Ìï¥Ï†úÌïòÍ≥† ÏÑ†ÌÉùÏ∞ΩÏúºÎ°ú ÎêòÎèåÎ¶¨ÏãúÍ≤†ÏäµÎãàÍπå?`, [
                        { text: "Ï∑®ÏÜå", class: "bg-gray-600" },
                        { text: "Ìï¥Ï†ú", class: "bg-red-600", onClick: () => removeCharacterPlacement(character.id, character.name) }
                    ]);
                };
            }
        }
        profileModal.classList.remove('hidden');
        document.getElementById('close-modal-btn').onclick = () => closeModal('profile-modal');
    }
    function closeModal(modalId) { document.getElementById(modalId).classList.add('hidden'); }
    
    // --- Admin Functions ---
    
    async function resetBoardPositions() {
        if (!gameId) return;
        const batch = writeBatch(db);
        characters.forEach(char => {
            const charRef = doc(db, 'games', gameId, 'characters', char.id);
            batch.update(charRef, { x: null, y: null });
        });
        await batch.commit();
        await logAction("üîÑ Í¥ÄÎ¶¨ÏûêÍ∞Ä Î™®Îì† Ï∫êÎ¶≠ÌÑ∞Î•º ÎØ∏Î∞∞Ïπò ÏÉÅÌÉúÎ°ú ÎêòÎèåÎ†∏ÏäµÎãàÎã§.", "admin");
        selectedCharacterId = null;
        render();
    }

    async function resetAllGameData() {
        if (!gameId) return;
        await resetBoardPositions();
        await seedInitialCharacters(gameId);
        await setDoc(doc(db, 'games', gameId, 'board', 'tiles'), { tiles: {} });
        await setDoc(doc(db, 'games', gameId), { gameState: 'PREPARATION', currentTurnIndex: 0, currentTurnCharId: null, round: 1 }, { merge: true });
        await logAction("‚ö†Ô∏è Í¥ÄÎ¶¨ÏûêÍ∞Ä Ï†ÑÏ≤¥ Í≤åÏûÑÏùÑ Ï¥àÍ∏∞ÌôîÌñàÏäµÎãàÎã§. Ï∫êÎ¶≠ÌÑ∞ Î™©Î°ùÍ≥º ÎßµÏù¥ Í∏∞Î≥∏ ÏÉÅÌÉúÎ°ú Î≥µÏõêÎê©ÎãàÎã§.", "admin");
    }

    // --- Map Edit Close Functions (Refactored) ---
    
    // 1. Îßµ Ìé∏Ïßë Î™®ÎìúÎ•º ÏôÑÏ†ÑÌûà ÎÅÑÎäî Ìï®Ïàò (isMapEditMode = false)
    function confirmExitMapEditMode() {
        isMapEditMode = false; // Mode OFF
        closeModal('map-edit-modal');
        logAction("üó∫Ô∏è Í¥ÄÎ¶¨ÏûêÍ∞Ä Îßµ Ìé∏Ïßë Î™®ÎìúÎ•º Ï¢ÖÎ£åÌñàÏäµÎãàÎã§.", "admin");
        updateAuthStatus();
    }

    // 2. Îßµ Ìé∏Ïßë ÌåùÏóÖÎßå ÏùºÏãúÏ†ÅÏúºÎ°ú Ïà®Í∏∞Îäî Ìï®Ïàò (isMapEditMode = true Ïú†ÏßÄ)
    function hideMapEditModalTemporarily() {
        closeModal('map-edit-modal');
        // isMapEditMode ÏÉÅÌÉúÎäî Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏäµÎãàÎã§.
        updateAuthStatus();
    }
    
    // Îßµ Ìé∏Ïßë Î™®Îìú ON
    function openMapEditModal() {
        if (!isAdmin || gameState !== 'PREPARATION') {
             showCustomModal("Í∂åÌïú Ïò§Î•ò", "Îßµ Ìé∏ÏßëÏùÄ Í¥ÄÎ¶¨ÏûêÎßå, Í∑∏Î¶¨Í≥† Í≤åÏûÑ Ï§ÄÎπÑ Îã®Í≥ÑÏóêÏÑúÎßå Í∞ÄÎä•Ìï©ÎãàÎã§.", [{text:"ÌôïÏù∏", class:"bg-red-600"}]);
             return;
        }
        // Îßµ Ìé∏Ïßë Î™®ÎìúÎ•º Ïó¥ Îïå Í¥ÄÎ¶¨Ïûê Ìå®ÎÑêÏùÑ Îã´ÏäµÎãàÎã§.
        closeModal('admin-modal'); 

        isMapEditMode = true;
        currentTileType = 'normal';
        mapEditModal.classList.remove('hidden');
        document.getElementById('map-edit-status').textContent = 'ÌòÑÏû¨ ÏÑ†ÌÉù: ÏùºÎ∞ò Ïπ∏';
        updateAuthStatus();
    }

    async function saveBoardTile(x, y, type) {
        if (!gameId) return;
        const tileKey = `${x},${y}`;
        const newTiles = { ...boardTiles };

        if (type === 'normal') {
            delete newTiles[tileKey];
        } else {
            newTiles[tileKey] = { type };
        }
        
        await setDoc(doc(db, 'games', gameId, 'board', 'tiles'), { tiles: newTiles });
        await logAction(`üó∫Ô∏è Í¥ÄÎ¶¨ÏûêÍ∞Ä (${x}, ${y}) Ïπ∏ÏùÑ ${type === 'obstacle' ? 'Ïû•Ïï†Î¨º(üö´)' : (type === 'damage' ? 'ÎåÄÎØ∏ÏßÄ Ïπ∏(ü©∏)' : 'ÏùºÎ∞ò Ïπ∏')}ÏúºÎ°ú ÏÑ§Ï†ïÌñàÏäµÎãàÎã§.`, "admin");
    }

    function openAdminModal() {
        if (!gameId) return;

        // Í¥ÄÎ¶¨Ïûê Ìå®ÎÑêÏùÑ Ïó¥ Îïå Îßµ Ìé∏Ïßë Î™®Îã¨ÏùÑ Îã´ÏäµÎãàÎã§.
        closeModal('map-edit-modal'); 
        // isMapEditModeÎäî Map Edit ModalÏùò Ï¢ÖÎ£å Î≤ÑÌäºÏóê ÏùòÌï¥ÏÑúÎßå falseÎ°ú Î∞îÎÄùÎãàÎã§.
        
        const container = document.getElementById('admin-modal-content');
        container.innerHTML = `<div class="flex justify-between items-center mb-6"><h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">Í¥ÄÎ¶¨Ïûê Ìå®ÎÑê</h3><button id="close-admin-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button></div>`;

        // Game State Management
        container.innerHTML += `<div class="mb-8 p-4 border border-gray-700 rounded-md">
            <h4 class="font-bold text-lg mb-4 text-yellow-400">Í≤åÏûÑ ÏßÑÌñâ Í¥ÄÎ¶¨</h4>
            <div class="grid grid-cols-2 gap-4">
                <button id="set-prep-phase-btn" class="w-full bg-blue-600 p-2">Ï§ÄÎπÑ Îã®Í≥ÑÎ°ú ÏÑ§Ï†ï</button>
                <button id="set-start-phase-btn" class="w-full bg-green-600 p-2">Í≤åÏûÑ ÏãúÏûë</button>
                <button id="prev-turn-btn" class="w-full bg-gray-600 p-2">Ïù¥Ï†Ñ ÌÑ¥ÏúºÎ°ú</button>
                <button id="next-turn-btn" class="w-full bg-gray-600 p-2">Îã§Ïùå ÌÑ¥ÏúºÎ°ú</button>
            </div>
            
            <div class="mt-6 p-3 border border-gray-600 rounded-md">
                <h5 class="text-sm font-bold text-indigo-400 mb-2">Î∞∞Í≤Ω ÏùåÏïÖ ÏÑ§Ï†ï</h5>
                <input type="text" id="admin-music-url-input" placeholder="Ïú†ÌäúÎ∏å URL ÎòêÎäî ID" class="form-input mb-2" value="">
                <input type="text" id="admin-music-name-input" placeholder="Ìä∏Îûô Ïù¥Î¶Ñ (ÏÑ†ÌÉù ÏÇ¨Ìï≠)" class="form-input mb-2" value="">
                <button id="set-music-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 p-2">Î∞∞Í≤Ω ÏùåÏïÖ Ï†ÅÏö© / ÏóÖÎç∞Ïù¥Ìä∏</button>
                <button id="stop-music-btn" class="w-full mt-2 bg-red-600 hover:bg-red-700 p-2">Î∞∞Í≤Ω ÏùåÏïÖ Ï§ëÏßÄ</button>
            </div>

            <div class="mt-4 grid grid-cols-2 gap-4">
                <button id="reset-board-pos-btn" class="w-full bg-red-700 p-2">Î≥¥Îìú Ï¥àÍ∏∞Ìôî (ÎØ∏Î∞∞Ïπò)</button>
                <button id="reset-all-game-btn" class="w-full bg-red-900 p-2">‚ö†Ô∏è Ï†ÑÏ≤¥ Í≤åÏûÑ Ïû¨ÏãúÏûë</button>
            </div>
            <div class="mt-4">
                <label for="max-rounds-input" class="block text-sm font-medium text-gray-300">ÏµúÎåÄ ÎùºÏö¥Îìú (0=Î¨¥Ìïú)</label>
                <div class="flex gap-2 mt-1">
                    <input type="number" id="max-rounds-input" class="form-input" value="${maxRounds}">
                    <button id="save-max-rounds-btn" class="bg-indigo-600 p-2 px-4">Ï†ÄÏû•</button>
                </div>
            </div>
            <div class="mt-4 flex items-center">
                <input type="checkbox" id="admin-move-toggle" class="form-checkbox h-5 w-5 text-purple-600 transition duration-150 ease-in-out" ${isAdminMoveAllowed ? 'checked' : ''}>
                <label for="admin-move-toggle" class="ml-2 block text-sm text-gray-300 font-medium">Í¥ÄÎ¶¨Ïûê ÌÜ†ÌÅ∞ Ïù¥Îèô ÌóàÏö© (ÌÑ¥ Î¨¥Ïãú)</label>
            </div>
        </div>`;
        
        // Map Edit Toggle
        container.innerHTML += `<div class="mb-8 p-4 border border-gray-700 rounded-md">
            <h4 class="font-bold text-lg mb-4 text-yellow-400">Îßµ/ÏßÄÌòï Í¥ÄÎ¶¨</h4>
            <button id="open-map-edit-btn" class="w-full bg-purple-600 p-2 font-bold ${gameState !== 'PREPARATION' ? 'opacity-50 cursor-not-allowed' : ''}" ${gameState !== 'PREPARATION' ? 'disabled' : ''}>Îßµ Ìé∏Ïßë Î™®Îìú ${isMapEditMode ? 'Ï¢ÖÎ£å' : 'ÏãúÏûë'}</button>
        </div>`;


        // Skill Management (Categorized view)
        const skillsByCategory = Object.values(SKILLS).reduce((acc, s) => {
            const category = s.category || 'Other';
            if (!acc[category]) acc[category] = [];
            acc[category].push(s);
            return acc;
        }, {});

        let skillHtml = `
        <div id="admin-skill-list" class="space-y-6">
            <h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">Ïä§ÌÇ¨ Î™©Î°ù/Ìé∏Ïßë</h3>`;

        SKILL_CATEGORIES.forEach(category => {
            const skills = skillsByCategory[category];
            if (skills && skills.length > 0) {
                const categoryColor = {
                    'Attack': 'border-red-600',
                    'Support': 'border-blue-600',
                    'Heal': 'border-green-600',
                    'Utility': 'border-gray-500',
                    'Defense': 'border-yellow-600',
                    'Other': 'border-purple-600'
                }[category];

                skillHtml += `<div class="mt-4">
                    <h4 class="font-bold text-xl mb-3 text-white border-b border-gray-700 pb-1">${category} Ïä§ÌÇ¨</h4>
                    <div class="space-y-3">`;
                
                skills.sort((a, b) => a.name.localeCompare(b.name)).forEach(s => {
                    // Check if specific costs exist to display them
                    const costDisplay = [
                        s.mpCost > 0 ? `${s.mpCost} MP` : '',
                        s.hpCost > 0 ? `${s.hpCost} HP` : ''
                    ].filter(Boolean).join(', ');

                    skillHtml += `<div class="p-4 rounded-md bg-gray-800 border-l-4 ${categoryColor}">
                        <h4 class="font-bold text-lg">${s.icon} ${s.name} <span class="text-sm text-gray-400">(${s.id})</span></h4>
                        <p class="text-xs text-gray-500 mb-2">ÎπÑÏö©: ${costDisplay || 'ÏóÜÏùå'} | Î≤îÏúÑ: ${s.range} | Í≥ÑÏàò: ${s.multiplier} | Ïú†Ìòï: ${s.type}</p>
                        <div class="grid grid-cols-4 gap-2 mt-2">
                            <input id="admin-name-${s.id}" class="form-input col-span-2" placeholder="Ïù¥Î¶Ñ" value="${s.name}">
                            <input id="admin-category-${s.id}" class="form-input" placeholder="Î∂ÑÎ•ò (Attack/Support...)" value="${s.category || 'Other'}">
                            <input id="admin-type-${s.id}" class="form-input" placeholder="ÌÉÄÏûÖ (Melee/Heal...)" value="${s.type}">
                            <input id="admin-icon-${s.id}" placeholder="ÏïÑÏù¥ÏΩò" class="form-input" value="${s.icon || ''}">
                            
                            <input id="admin-range-${s.id}" type="number" class="form-input" placeholder="ÏÇ¨Í±∞Î¶¨" value="${s.range}">
                            <input id="admin-multiplier-${s.id}" type="number" step="0.1" class="form-input" placeholder="Í≥ÑÏàò" value="${s.multiplier}">
                            <input id="admin-mpcost-${s.id}" type="number" class="form-input" placeholder="MP ÎπÑÏö©" value="${s.mpCost || 0}">
                            <input id="admin-hpcost-${s.id}" type="number" class="form-input" placeholder="HP ÎπÑÏö©" value="${s.hpCost || 0}">
                        </div>
                        <div class="flex justify-between items-center mt-2 pt-2 border-t border-gray-700/50">
                            <button data-skill-id="${s.id}" class="save-skill-btn bg-green-600 p-2 text-sm flex-grow mr-2">Ï†ÄÏû•</button>
                            <button data-skill-id="${s.id}" data-skill-name="${s.name}" class="delete-skill-btn bg-red-700 hover:bg-red-600 p-2 text-sm text-white">ÏÇ≠Ï†ú</button>
                        </div>
                    </div>`;
                });
                skillHtml += `</div></div>`;
            }
        });

        skillHtml += `<div class="mt-8 pt-4 border-t border-gray-700">
            <h4 class="font-bold text-lg mb-2 text-green-400">ÏÉà Ïä§ÌÇ¨ Ï∂îÍ∞Ä</h4>
            <div class="grid grid-cols-2 gap-4">
                <input id="new-skill-id" placeholder="Ïä§ÌÇ¨ ID (e.g., fireball)" class="form-input">
                <input id="new-skill-name" placeholder="Ïä§ÌÇ¨ Ïù¥Î¶Ñ" class="form-input">
                <select id="new-skill-category" class="form-input bg-gray-700">
                    ${SKILL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join('')}
                </select>
                <select id="new-skill-type" class="form-input bg-gray-700">
                    <option value="Melee">Melee</option><option value="Ranged">Ranged</option><option value="Heal">Heal</option><option value="Utility">Utility</option><option value="Support">Support</option>
                </select>
                <input id="new-skill-icon" placeholder="ÏïÑÏù¥ÏΩò (e.g., üî•)" class="form-input">
                <input id="new-skill-range" type="number" placeholder="Î≤îÏúÑ" class="form-input">
                <input id="new-skill-multiplier" type="number" step="0.1" placeholder="ÌîºÌï¥/ÌöåÎ≥µ Í≥ÑÏàò" class="form-input">
                <input id="new-skill-mpcost" type="number" placeholder="MP ÎπÑÏö©" class="form-input" value="0">
            </div>
            <button id="add-new-skill-btn" class="mt-4 bg-blue-600 p-2 w-full">ÏÉà Ïä§ÌÇ¨ Ï†ÄÏû•</button>
        </div></div>`;
        container.innerHTML += skillHtml;

        // Character Management 
        container.innerHTML += `<div class="mt-8 pt-4 border-t border-gray-700">
            <h4 class="font-bold text-lg mb-2 text-green-400">ÏÉà Ï∫êÎ¶≠ÌÑ∞/ÏóêÎÑàÎØ∏ Ï∂îÍ∞Ä</h4>
            <div class="grid grid-cols-2 gap-4">
                <input id="new-char-name" placeholder="Ïù¥Î¶Ñ" class="form-input">
                <select id="new-char-type" class="form-input bg-gray-700"><option value="PC">PC</option><option value="ENEMY">ENEMY</option></select>
                <input id="new-char-imageUrl" placeholder="Ïù¥ÎØ∏ÏßÄ URL" class="form-input col-span-2">
                
                <div class="relative"><input id="new-char-hp" type="number" placeholder=" " class="form-input peer" value="100"><label for="new-char-hp" class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">HP (Ï≤¥Î†•)</label></div>
                <div class="relative"><input id="new-char-mp" type="number" placeholder=" " class="form-input peer" value="50"><label for="new-char-mp" class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">MP (ÎßàÎÇò)</label></div>
                
                <div class="relative"><input id="new-char-min-attack" type="number" placeholder=" " class="form-input peer" value="10"><label for="new-char-min-attack" class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">ÏµúÏÜå Í≥µÍ≤©Î†•</label></div>
                <div class="relative"><input id="new-char-max-attack" type="number" placeholder=" " class="form-input peer" value="15"><label for="new-char-max-attack" class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">ÏµúÎåÄ Í≥µÍ≤©Î†•</label></div>

                <div class="relative"><input id="new-char-min-defense" type="number" placeholder=" " class="form-input peer" value="3"><label for="new-char-min-defense" class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">ÏµúÏÜå Î∞©Ïñ¥Î†•</label></div>
                <div class="relative"><input id="new-char-max-defense" type="number" placeholder=" " class="form-input peer" value="7"><label for="new-char-max-defense" class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">ÏµúÎåÄ Î∞©Ïñ¥Î†•</label></div>

                <div class="relative"><input id="new-char-size" type="number" placeholder=" " class="form-input peer" value="1"><label for="new-char-size" class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">ÌÅ¨Í∏∞ (1x1, 2x2...)</label></div>
                <input id="new-char-skills" placeholder="Ïä§ÌÇ¨ ID (e.g. slash,shoot)" class="form-input">
            </div>
            <button id="add-new-char-btn" class="mt-4 bg-blue-600 p-2 w-full">ÏÉà Ï∫êÎ¶≠ÌÑ∞ Ï†ÄÏû•</button>
        </div>`;

        document.getElementById('close-admin-modal-btn').onclick = () => closeModal('admin-modal');

        // Set Admin Music Inputs with current values
        const gameDocRef = doc(db, 'games', gameId);
        getDoc(gameDocRef).then(docSnap => {
             if (docSnap.exists()) {
                 const data = docSnap.data();
                 document.getElementById('admin-music-url-input').value = data.musicUrl || '';
                 document.getElementById('admin-music-name-input').value = data.musicName || '';
             }
        });


        document.getElementById('set-music-btn').onclick = async () => {
            const url = document.getElementById('admin-music-url-input').value.trim();
            const name = document.getElementById('admin-music-name-input').value.trim() || 'ÏßÄÏ†ïÎêú Ìä∏Îûô';
            if (url && gameId) {
                await updateDoc(doc(db, 'games', gameId), { musicUrl: url, musicName: name });
                showCustomModal("ÏùåÏïÖ Ï†ÅÏö©", `Î∞∞Í≤Ω ÏùåÏïÖÏùÑ '${name}'ÏúºÎ°ú ÏÑ§Ï†ïÌñàÏäµÎãàÎã§.`, [{text: "ÌôïÏù∏", class: "bg-green-600"}]);
            } else {
                 showCustomModal("Ïò§Î•ò", "Ïú†ÌäúÎ∏å URLÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.", [{text: "ÌôïÏù∏", class: "bg-red-600"}]);
            }
        };
        
        document.getElementById('stop-music-btn').onclick = async () => {
            if (gameId) {
                await updateDoc(doc(db, 'games', gameId), { musicUrl: '', musicName: '' });
                showCustomModal("ÏùåÏïÖ Ï§ëÏßÄ", "Î∞∞Í≤Ω ÏùåÏïÖ Ïû¨ÏÉùÏùÑ Ï§ëÏßÄÌñàÏäµÎãàÎã§.", [{text: "ÌôïÏù∏", class: "bg-green-600"}]);
            }
        };


        document.getElementById('set-prep-phase-btn').onclick = async () => {
            if (gameId) {
                await updateDoc(doc(db, 'games', gameId), { gameState: 'PREPARATION', currentTurnIndex: 0, currentTurnCharId: null, round: 1 });
                await logAction("üõ†Ô∏è Í¥ÄÎ¶¨ÏûêÍ∞Ä Í≤åÏûÑÏùÑ Ï§ÄÎπÑ Îã®Í≥ÑÎ°ú ÏÑ§Ï†ïÌñàÏäµÎãàÎã§.", "system");
                showCustomModal("ÏÉÅÌÉú Î≥ÄÍ≤Ω", "Í≤åÏûÑÏù¥ Ï§ÄÎπÑ Îã®Í≥ÑÎ°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§. ÏûêÏú†Î°≠Í≤å ÌÜ†ÌÅ∞ÏùÑ Î∞∞ÏπòÌïòÏÑ∏Ïöî.", [{text: "ÌôïÏù∏", class: "bg-blue-600"}]);
            }
        };
        document.getElementById('set-start-phase-btn').onclick = async () => {
            if (gameId) {
                await updateDoc(doc(db, 'games', gameId), { gameState: 'STARTED' });
                await logAction("‚öîÔ∏è Í≤åÏûÑÏù¥ ÏãúÏûëÎêòÏóàÏäµÎãàÎã§! Ï≤´ Î≤àÏß∏ ÌÑ¥Î∂ÄÌÑ∞ ÏßÑÌñâÌï©ÎãàÎã§.", "system");
                showCustomModal("Í≤åÏûÑ ÏãúÏûë", "Ï†ÑÌà¨Î•º ÏãúÏûëÌï©ÎãàÎã§!", [{text: "ÌôïÏù∏", class: "bg-green-600"}]);
            }
        };
        document.getElementById('prev-turn-btn').onclick = async () => { if (gameId) await previousTurn(); };
        document.getElementById('next-turn-btn').onclick = async () => { if (gameId) await nextTurn(); };
        document.getElementById('save-max-rounds-btn').onclick = async () => {
            if (gameId) {
                const newMaxRounds = parseInt(document.getElementById('max-rounds-input').value) || 0;
                await updateDoc(doc(db, 'games', gameId), { maxRounds: newMaxRounds });
                showCustomModal("ÏÑ§Ï†ï Ï†ÄÏû•", `ÏµúÎåÄ ÎùºÏö¥ÎìúÍ∞Ä ${newMaxRounds > 0 ? newMaxRounds : 'Î¨¥Ìïú'}ÏúºÎ°ú ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§.`, [{text: "ÌôïÏù∏", class: "bg-indigo-600"}]);
            }
        };
        document.getElementById('reset-board-pos-btn').onclick = resetBoardPositions;
        document.getElementById('reset-all-game-btn').onclick = async () => {
            showCustomModal("Ï†ÑÏ≤¥ Ï¥àÍ∏∞Ìôî Í≤ΩÍ≥†", "Î™®Îì† Ï∫êÎ¶≠ÌÑ∞, Îßµ ÏßÄÌòï, Í≤åÏûÑ Î°úÍ∑∏Í∞Ä ÏôÑÏ†ÑÌûà Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?", [
                { text: "Ï∑®ÏÜå", class: "bg-gray-600" },
                { text: "ÌôïÏù∏ (Ï¥àÍ∏∞Ìôî)", class: "bg-red-600", onClick: resetAllGameData }
            ]);
        };

        document.getElementById('open-map-edit-btn').onclick = openMapEditModal;


        document.getElementById('admin-move-toggle').onchange = async (e) => {
            const isChecked = e.target.checked;
            if (gameId) {
                await setDoc(doc(db, 'games', gameId), { isAdminMoveAllowed: isChecked }, { merge: true });
                await logAction(`üëÆ Í¥ÄÎ¶¨Ïûê ÌÜ†ÌÅ∞ Ïù¥Îèô Í∂åÌïúÏù¥ ${isChecked ? 'ÌóàÏö©' : 'Ï†úÌïú'}ÎêòÏóàÏäµÎãàÎã§.`, "admin-move");
            }
        };
        
        document.querySelectorAll('.save-skill-btn').forEach(btn => {
            btn.onclick = async e => {
                const id = e.target.dataset.skillId;
                const updated = { 
                    ...SKILLS[id], 
                    name: document.getElementById(`admin-name-${id}`).value, 
                    range: parseFloat(document.getElementById(`admin-range-${id}`).value), 
                    multiplier: parseFloat(document.getElementById(`admin-multiplier-${id}`).value),
                    type: document.getElementById(`admin-type-${id}`).value,
                    icon: document.getElementById(`admin-icon-${id}`).value,
                    category: document.getElementById(`admin-category-${id}`).value,
                    mpCost: parseInt(document.getElementById(`admin-mpcost-${id}`).value) || 0,
                    hpCost: parseInt(document.getElementById(`admin-hpcost-${id}`).value) || 0,
                };
                if (gameId) { await setDoc(doc(db, 'games', gameId), { skills: { ...SKILLS, [id]: updated } }, { merge: true }); }
            };
        });
        
        document.querySelectorAll('.delete-skill-btn').forEach(btn => { // NEW: Delete skill listener
            btn.onclick = (e) => {
                const skillId = e.currentTarget.dataset.skillId;
                const skillName = e.currentTarget.dataset.skillName;
                showCustomModal("Ïä§ÌÇ¨ ÏÇ≠Ï†ú ÌôïÏù∏", `**${skillName}** Ïä§ÌÇ¨ÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå? Ïù¥ Ïä§ÌÇ¨ÏùÑ Í∞ÄÏßÑ Î™®Îì† Ï∫êÎ¶≠ÌÑ∞ÏóêÏÑú Ï†úÍ±∞Îê©ÎãàÎã§.`, [
                    { text: "Ï∑®ÏÜå", class: "bg-gray-600" },
                    { text: "ÏÇ≠Ï†ú", class: "bg-red-600", onClick: () => deleteSkill(skillId, skillName) }
                ]);
            };
        });

        document.getElementById('add-new-skill-btn').onclick = async () => {
            const newId = document.getElementById('new-skill-id').value.trim();
            if (!newId || SKILLS[newId]) {
                showCustomModal("Ïò§Î•ò", "Ïú†Ìö®ÌïòÏßÄ ÏïäÍ±∞ÎÇò Ï§ëÎ≥µÎêú Ïä§ÌÇ¨ IDÏûÖÎãàÎã§.", [{text: "ÌôïÏù∏", class: "bg-red-600"}]);
                return;
            }
            const newSkill = { 
                id: newId, 
                name: document.getElementById('new-skill-name').value, 
                type: document.getElementById('new-skill-type').value, 
                icon: document.getElementById('new-skill-icon').value, 
                range: parseFloat(document.getElementById('new-skill-range').value) || 0, 
                multiplier: parseFloat(document.getElementById('new-skill-multiplier').value) || 0,
                category: document.getElementById('new-skill-category').value,
                mpCost: parseInt(document.getElementById('new-skill-mpcost').value) || 0,
                hpCost: 0, // Default 0 for simplicity in this panel
            };
            if (gameId) {
                await setDoc(doc(db, 'games', gameId), { skills: { ...SKILLS, [newId]: newSkill } }, { merge: true });
                showCustomModal("ÏÑ±Í≥µ", `'${newSkill.name}' Ïä§ÌÇ¨Ïù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.`, [{text: "ÌôïÏù∏", class: "bg-green-600"}]);
            }
        };

        document.getElementById('add-new-char-btn').onclick = async () => {
            const name = document.getElementById('new-char-name').value.trim();
            if (!name) { showCustomModal("Ïò§Î•ò", "Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§.", [{text: "ÌôïÏù∏", class: "bg-red-600"}]); return; }
            const type = document.getElementById('new-char-type').value;
            const skills = document.getElementById('new-char-skills').value.split(',').map(s => s.trim()).filter(Boolean);
            
            const newChar = { name: name, type: type, imageUrl: document.getElementById('new-char-imageUrl').value.trim(), 
                hp: parseInt(document.getElementById('new-char-hp').value) || 100, maxHp: parseInt(document.getElementById('new-char-hp').value) || 100, 
                mp: parseInt(document.getElementById('new-char-mp').value) || 50, maxMp: parseInt(document.getElementById('new-char-mp').value) || 50, 
                minAttack: parseInt(document.getElementById('new-char-min-attack').value) || 10, maxAttack: parseInt(document.getElementById('new-char-max-attack').value) || 15, 
                minDefense: parseInt(document.getElementById('new-char-min-defense').value) || 3, maxDefense: parseInt(document.getElementById('new-char-max-defense').value) || 7, 
                size: parseInt(document.getElementById('new-char-size').value) || 1, 
                skills: skills, x: null, y: null, turnOrder: characters.length + 1, password: type === 'PC' ? DEFAULT_PC_PASSWORD : '' };
            
            if (gameId) {
                await addDoc(collection(db, "games", gameId, "characters"), newChar);
                showCustomModal("ÏÑ±Í≥µ", `'${newChar.name}' Ï∫êÎ¶≠ÌÑ∞Í∞Ä Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.`, [{text: "ÌôïÏù∏", class: "bg-green-600"}]);
            }
        };

        adminModal.classList.remove('hidden');
    }

    // --- Event Listeners ---
    
    function canControlCharacter(charId) {
        const char = characters.find(c => c.id === charId);
        if (!char || char.hp <= 0) return false;

        if (isAdmin && isAdminMoveAllowed) return true;

        if (loggedInCharId !== charId) return false; 

        const currentTurnChar = characters[currentTurnIndex];
        if (gameState === 'STARTED' && currentTurnChar && currentTurnChar.id === charId) return true;
        if (gameState === 'PREPARATION' && char.type === 'PC') return true;
        
        return false;
    }

    function isCellOccupied(targetX, targetY, movingCharId = null) {
        // Check for character occupancy
        const isCharOccupied = characters.some(char => {
            if (char.id === movingCharId || char.x === null) return false;
            const size = char.size || 1;
            return targetX >= char.x && targetX < (char.x + size) && targetY >= char.y && targetY < (char.y + size);
        });

        // Check for obstacle tile
        const tileKey = `${targetX},${targetY}`;
        const isObstacle = boardTiles[tileKey]?.type === 'obstacle';
        
        return isCharOccupied || isObstacle;
    }

    function canPlaceCharacter(charToPlace, targetX, targetY) {
        const size = charToPlace.size || 1;
        if (targetX < 0 || targetY < 0 || targetX + size > BOARD_SIZE || targetY + size > BOARD_SIZE) return false;
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                if (isCellOccupied(targetX + i, targetY + j, charToPlace.id)) return false;
            }
        }
        return true;
    }

    async function handlePreparationClick(e) {
        const token = e.target.closest('.character-token');
        const cell = e.target.closest('.cell');
        if (!cell) return;
        const x = parseInt(cell.dataset.x);
        const y = parseInt(cell.dataset.y);

        // NEW: Map Edit Mode takes precedence in PREPARATION phase if admin
        if (isAdmin && isMapEditMode) {
            await saveBoardTile(x, y, currentTileType);
            return;
        }

        if (token) {
            selectedCharacterId = token.dataset.charId;
            render();
        } else if (selectedCharacterId) {
            const targetChar = characters.find(c => c.id === selectedCharacterId);
            const isPC = targetChar?.type === 'PC';

            if (isAdmin && isAdminMoveAllowed || (isPC && loggedInCharId === selectedCharacterId && gameState === 'PREPARATION')) {
                if (targetChar && canPlaceCharacter(targetChar, x, y)) {
                    await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacterId), { x: x, y: y });
                    if (targetChar.x === null) {
                       await logAction(`‚úÖ ${targetChar.name}Ïù¥(Í∞Ä) Ï†ÑÏû•Ïóê Ìï©Î•òÌñàÏäµÎãàÎã§.`, "join");
                    } else if (isAdmin) {
                       await logAction(`üëÆ Í¥ÄÎ¶¨ÏûêÍ∞Ä ${targetChar.name}ÏùÑ(Î•º) (${targetChar.x},${targetChar.y})ÏóêÏÑú (${x}, ${y})Î°ú Ïù¥ÎèôÌñàÏäµÎãàÎã§.`, "admin-move");
                    }
                    selectedCharacterId = null;
                } else {
                     showCustomModal("Î∞∞Ïπò Ïò§Î•ò", "Ìï¥Îãπ ÏúÑÏπòÎäî Ïù¥ÎØ∏ Îã§Î•∏ Ï∫êÎ¶≠ÌÑ∞Í∞Ä Ï∞®ÏßÄÌïòÍ≥† ÏûàÍ±∞ÎÇò Ïû•Ïï†Î¨ºÏûÖÎãàÎã§.", [{ text: "ÌôïÏù∏", class: "bg-red-600" }]);
                }
            } else {
                showCustomModal("Í∂åÌïú Î∂ÄÏ°±", `${targetChar?.name || 'Ï∫êÎ¶≠ÌÑ∞'}Î•º Î∞∞ÏπòÌïòÎ†§Î©¥ Î°úÍ∑∏Ïù∏ÌïòÍ±∞ÎÇò Í¥ÄÎ¶¨Ïûê Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.`, [{ text: "ÌôïÏù∏", class: "bg-red-600" }]);
            }
        } else {
             selectedCharacterId = null;
             render();
        }
    }

    async function handleCombatClick(e) {
        const token = e.target.closest('.character-token');
        const cell = e.target.closest('.cell');
        if (!cell) return;
        
        const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
        const currentTurnChar = characters[currentTurnIndex];
        
        const isControllable = selectedCharacter && canControlCharacter(selectedCharacter.id);
        
        if (token) {
            const clickedCharId = token.dataset.charId;
            const clickedChar = characters.find(c => c.id === clickedCharId);
            
            if (e.detail === 2) {
                openProfileModal(clickedChar);
                return;
            }

            if (currentTurnChar?.id === clickedCharId && (isAdmin || loggedInCharId === clickedCharId)) {
                selectedCharacterId = clickedCharId;
                // NEW: If already selected and in MOVE phase, treat a click on self as skipping move.
                if (selectedCharacterId === clickedCharId && turnPhase === 'MOVE') {
                    const cellX = parseInt(cell.dataset.x);
                    const cellY = parseInt(cell.dataset.y);
                    // Check if the click is on the character's current cell(s)
                    const isClickOnSelf = cellX >= clickedChar.x && cellX < (clickedChar.x + (clickedChar.size || 1)) &&
                                          cellY >= clickedChar.y && cellY < (clickedChar.y + (clickedChar.size || 1));
                    
                    if (isClickOnSelf) {
                        turnPhase = 'ACTION'; // Skip move phase
                        selectedSkill = null;
                        preMovePosition = { x: clickedChar.x, y: clickedChar.y };
                        logAction(`‚è© ${clickedChar.name}Ïù¥(Í∞Ä) Ï†úÏûêÎ¶¨ Ïù¥ÎèôÏúºÎ°ú Îã®Í≥ÑÎ•º Í±¥ÎÑàÎõ∞ÏóàÏäµÎãàÎã§.`, "system");
                        render();
                        return;
                    }
                }
                
                selectedSkill = 'move';
                preMovePosition = { x: clickedChar.x, y: char.y };
                render();
                return;
            }
        }
        
        if (!isControllable) { 
             selectedCharacterId = null; 
             selectedSkill = null; 
             render(); 
             return;
        }

        if (turnPhase === 'MOVE') {
            if (token && token.dataset.charId === selectedCharacterId) { 
                // Handled above or by marker click
            } 
            
            const newX = parseInt(cell.dataset.x), newY = parseInt(cell.dataset.y);
            const tileType = boardTiles[`${newX},${newY}`]?.type;

            if (tileType === 'obstacle' && !isAdmin) {
                showCustomModal("Ïù¥Îèô Î∂àÍ∞Ä", "Ïù¥ Ïπ∏ÏùÄ Ïû•Ïï†Î¨ºÏûÖÎãàÎã§. Ïù¥ÎèôÌï† Ïàò ÏóÜÏäµÎãàÎã§.", [{ text: "ÌôïÏù∏", class: "bg-red-600" }]);
                return;
            }

            // Use 'attack-range-move' class which covers all valid moves (including utility moves)
            if (canPlaceCharacter(selectedCharacter, newX, newY) && cell.classList.contains('attack-range-move')) {
                await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacter.id), { x: newX, y: newY });
                
                if (isAdmin) {
                    await logAction(`üëÆ Í¥ÄÎ¶¨ÏûêÍ∞Ä ${selectedCharacter.name}ÏùÑ(Î•º) (${selectedCharacter.x},${selectedCharacter.y})ÏóêÏÑú (${newX}, ${newY})Î°ú Ïù¥ÎèôÌñàÏäµÎãàÎã§.`, "admin-move");
                } else {
                    await logAction(`üèÉ ${selectedCharacter.name}Ïù¥(Í∞Ä) (${newX}, ${newY})(Ïúº)Î°ú Ïù¥ÎèôÌñàÏäµÎãàÎã§.`, "move");
                }
                
                turnPhase = 'ACTION'; selectedSkill = null; render();
            }
        } else if (turnPhase === 'ACTION') {
            const skill = SKILLS[selectedSkill];
            if (!skill) return;

            const isAttackSkill = skill.category === 'Attack';
            const isHealOrSupport = skill.category === 'Heal' || skill.category === 'Support';
            
            if (isAttackSkill) {
                // Check if current user has enough MP to attempt the skill
                if (selectedCharacter.mp < skill.mpCost) {
                    await logAction(`‚ö†Ô∏è ${selectedCharacter.name}Ïù¥(Í∞Ä) ÎßàÎÇòÍ∞Ä Î∂ÄÏ°±ÌïòÏó¨ ${skill.name}ÏùÑ(Î•º) ÏãúÏ†ÑÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.`, "system");
                    render();
                    return;
                }
                
                if (skill.isAoe) {
                    if (cell.classList.contains('attack-range-skill')) {
                        await executeSkill(selectedCharacter, { x: parseInt(cell.dataset.x), y: parseInt(cell.dataset.y) }, selectedSkill);
                    }
                } else if (token) {
                    const targetChar = characters.find(c => c.id === token.dataset.charId);
                    // Standard Attack: Target must be enemy (type check) and in range (class check)
                    if (targetChar && selectedCharacter.type !== targetChar.type && cell.classList.contains('attack-range-skill')) {
                        await executeSkill(selectedCharacter, targetChar, selectedSkill);
                    }
                }
            } else if (isHealOrSupport) {
                 // Check if current user has enough MP/HP to attempt the skill
                if (selectedCharacter.mp < skill.mpCost || (skill.hpCost && selectedCharacter.hp <= skill.hpCost)) {
                    await logAction(`‚ö†Ô∏è ${selectedCharacter.name}Ïù¥(Í∞Ä) ÏûêÏõê(MP/HP)Ïù¥ Î∂ÄÏ°±ÌïòÏó¨ ${skill.name}ÏùÑ(Î•º) ÏãúÏ†ÑÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.`, "system");
                    render();
                    return;
                }
                
                if (skill.isAoe) {
                    if (cell.classList.contains('heal-range-skill')) {
                        await executeSkill(selectedCharacter, { x: parseInt(cell.dataset.x), y: parseInt(cell.dataset.y) }, selectedSkill);
                    }
                } else if (token) {
                    const targetChar = characters.find(c => c.id === token.dataset.charId);
                    
                    let isValidTarget = false;
                    if (skill.targetType === 'ALLY_DEAD') {
                        // Resurrect: Target must be dead ally
                        if (targetChar && selectedCharacter.type === targetChar.type && targetChar.hp <= 0 && cell.classList.contains('heal-range-skill')) {
                            isValidTarget = true;
                        }
                    } else if (skill.targetType === 'ALLY') {
                        // Heal/Support: Target must be live ally
                         if (targetChar && selectedCharacter.type === targetChar.type && targetChar.hp > 0 && cell.classList.contains('heal-range-skill')) {
                            isValidTarget = true;
                        }
                    }
                    
                    if (isValidTarget) {
                        await executeSkill(selectedCharacter, targetChar, selectedSkill);
                    }
                }
            }
        }
    }

    async function gameBoardClick(e) {
        if(!gameId) return;
        if (gameState === 'PREPARATION') {
            await handlePreparationClick(e);
        } else if (gameState === 'STARTED') {
            await handleCombatClick(e);
        }
    }
    
    // --- Map Edit Modal Listeners ---
    document.querySelectorAll('.tile-select-btn').forEach(btn => {
        btn.onclick = (e) => {
            currentTileType = e.currentTarget.dataset.tileType;
            document.getElementById('map-edit-status').textContent = `ÌòÑÏû¨ ÏÑ†ÌÉù: ${e.currentTarget.textContent.trim()}`;
        };
    });

    // "Îßµ Ìé∏Ïßë Ï¢ÖÎ£å" Î≤ÑÌäºÎßå isMapEditModeÎ•º falseÎ°ú ÏÑ§Ï†ïÌï©ÎãàÎã§.
    document.getElementById('exit-map-edit-btn').onclick = confirmExitMapEditMode;
    
    // 'X' Î≤ÑÌäºÍ≥º Î∞∞Í≤Ω ÌÅ¥Î¶≠ÏùÄ ÌåùÏóÖÎßå Îã´Í≥† isMapEditModeÎäî Ïú†ÏßÄÌï©ÎãàÎã§.
    document.getElementById('close-map-edit-modal-btn').onclick = hideMapEditModalTemporarily; 
    mapEditModal.addEventListener('click', e => { 
        // Close only if the backdrop itself (map-edit-modal) is clicked
        if (e.target.id === 'map-edit-modal') hideMapEditModalTemporarily(); 
    });
    // --- End Map Edit Modal Listeners ---


    createGameBtn.addEventListener('click', createGame);
    joinGameBtn.addEventListener('click', () => joinGame(gameIdInput.value));
    leaveGameBtn.addEventListener('click', leaveGame);
    
    // User Info Modal Handlers
    userInfoBtn.addEventListener('click', () => { userInfoModal.classList.remove('hidden'); });
    // Fix: Use the dedicated button ID to close the User Info Modal
    document.getElementById('close-user-info-modal-btn').onclick = () => closeModal('user-info-modal');
    userInfoModal.addEventListener('click', (e) => { 
        // Only close if backdrop is clicked
        if (e.target.id === 'user-info-modal') closeModal('user-info-modal'); 
    });
    
    // Copy button inside User Info Modal
    document.getElementById('user-info-copy-btn').addEventListener('click', () => { 
        const input = document.getElementById('user-info-game-id-display');
        input.select(); 
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(input.value).then(() => {
                showCustomModal("Î≥µÏÇ¨ ÏôÑÎ£å", "Í≤åÏûÑ ÏΩîÎìúÍ∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§. (Modern API)", [{ text: "ÌôïÏù∏", class: "bg-green-600" }]);
            }).catch(err => {
                document.execCommand('copy');
                showCustomModal("Î≥µÏÇ¨ ÏôÑÎ£å", "Í≤åÏûÑ ÏΩîÎìúÍ∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§. (Fallback)", [{ text: "ÌôïÏù∏", class: "bg-green-600" }]);
                console.error('Async clipboard copy failed:', err);
            });
        } else {
             document.execCommand('copy');
             showCustomModal("Î≥µÏÇ¨ ÏôÑÎ£å", "Í≤åÏûÑ ÏΩîÎìúÍ∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§.", [{ text: "ÌôïÏù∏", class: "bg-green-600" }]);
        }
    });

    // Original Game ID container copy logic (still needed if the original container is shown in the lobby phase)
    copyGameIdBtn.addEventListener('click', () => { 
        const input = document.getElementById('game-id-display');
        input.select(); 
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(input.value).then(() => {
                showCustomModal("Î≥µÏÇ¨ ÏôÑÎ£å", "Í≤åÏûÑ ÏΩîÎìúÍ∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§. (Modern API)", [{ text: "ÌôïÏù∏", class: "bg-green-600" }]);
            }).catch(err => {
                document.execCommand('copy');
                showCustomModal("Î≥µÏÇ¨ ÏôÑÎ£å", "Í≤åÏûÑ ÏΩîÎìúÍ∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§. (Fallback)", [{ text: "ÌôïÏù∏", class: "bg-green-600" }]);
                console.error('Async clipboard copy failed:', err);
            });
        } else {
             document.execCommand('copy');
             showCustomModal("Î≥µÏÇ¨ ÏôÑÎ£å", "Í≤åÏûÑ ÏΩîÎìúÍ∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§.", [{ text: "ÌôïÏù∏", class: "bg-green-600" }]);
        }
    });
    
    document.getElementById('overlay-toggle').addEventListener('click', (e) => {
         const overlay = document.getElementById('character-selection-overlay');
         overlay.classList.toggle('collapsed');
         e.currentTarget.querySelector('svg').style.transform = overlay.classList.contains('collapsed') ? 'rotate(180deg)' : 'rotate(0deg)';
    });
    profileModal.addEventListener('click', e => { if (e.target.id === 'profile-modal') closeModal('profile-modal'); });
    
    document.getElementById('submit-char-login-btn').addEventListener('click', handlePCLogin);
    document.getElementById('cancel-char-login-btn').addEventListener('click', () => closeModal('pc-login-modal'));
    // Re-route original login/logout button handlers
    // document.getElementById('login-btn').addEventListener('click', openPCLoginModal); // Removed, now handled by User Info Modal
    // document.getElementById('logout-btn').addEventListener('click', handleLogout); // Removed, now handled by User Info Modal
    pcLoginModal.addEventListener('click', e => { if (e.target.id === 'pc-login-modal') closeModal('pc-login-modal'); });
    
    document.getElementById('admin-panel-btn').addEventListener('click', () => { 
        if (isAdmin) {
            openAdminModal();
        } else {
            adminPasswordModal.classList.remove('hidden'); document.getElementById('admin-password-input').focus();
        }
    });
    document.getElementById('cancel-admin-login-btn').addEventListener('click', () => closeModal('admin-password-modal'));
    
    document.getElementById('submit-admin-login-btn').addEventListener('click', async () => {
        const input = document.getElementById('admin-password-input');
        const errorP = document.getElementById('admin-password-error');
        if (gameId) {
            const gameDoc = await getDoc(doc(db, 'games', gameId));
            const correctPassword = gameDoc.data().adminPassword || "0000";
            if (input.value === correctPassword) {
                closeModal('admin-password-modal');
                isAdmin = true;
                loggedInCharId = null;
                openAdminModal();
                input.value = '';
                errorP.textContent = '';
                updateAuthStatus();
                await logAction("üëë Í¥ÄÎ¶¨ÏûêÍ∞Ä Î°úÍ∑∏Ïù∏ÌñàÏäµÎãàÎã§.", "system");
            } else {
                errorP.textContent = 'ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.';
                input.value = '';
            }
        }
    });

    gameBoard.addEventListener('click', gameBoardClick);
    gameBoard.addEventListener('dragover', e => e.preventDefault());
    gameBoard.addEventListener('drop', async e => {
        e.preventDefault(); if(!gameId) return;
        const charId = e.dataTransfer.getData('text/plain'), cell = e.target.closest('.cell');
        if (cell && charId) {
            const targetChar = characters.find(c => c.id === charId);
            const isPC = targetChar?.type === 'PC';

            const canDragAndDrop = (isAdmin && isAdminMoveAllowed) || (isPC && loggedInCharId === charId);

            if (targetChar && canDragAndDrop && (gameState === 'PREPARATION' || targetChar.x === null || isAdminMoveAllowed)) {
                const newX = parseInt(cell.dataset.x);
                const newY = parseInt(cell.dataset.y);

                if (canPlaceCharacter(targetChar, newX, newY)) {
                    await updateDoc(doc(db, 'games', gameId, 'characters', charId), { x: newX, y: newY });
                    
                     if (targetChar.x === null) {
                       await logAction(`‚úÖ ${targetChar.name}Ïù¥(Í∞Ä) Ï†ÑÏû•Ïóê Ìï©Î•òÌñàÏäµÎãàÎã§.`, "join");
                    } else if (isAdmin) {
                       await logAction(`üëÆ Í¥ÄÎ¶¨ÏûêÍ∞Ä ${targetChar.name}ÏùÑ(Î•º) (${targetChar.x},${targetChar.y})ÏóêÏÑú (${newX}, ${newY})Î°ú Ïù¥ÎèôÌñàÏäµÎãàÎã§.`, "admin-move");
                    }
                } else {
                     showCustomModal("Î∞∞Ïπò Ïò§Î•ò", "Ìï¥Îãπ ÏúÑÏπòÎäî Ïù¥ÎØ∏ Îã§Î•∏ Ï∫êÎ¶≠ÌÑ∞Í∞Ä Ï∞®ÏßÄÌïòÍ≥† ÏûàÍ±∞ÎÇò Ïû•Ïï†Î¨ºÏûÖÎãàÎã§.", [{ text: "ÌôïÏù∏", class: "bg-red-600" }]);
                }
            } else if (targetChar && targetChar.x !== null && gameState === 'STARTED') {
                showCustomModal("Í∂åÌïú Î∂ÄÏ°±", "Ï†ÑÌà¨ Ï§ëÏóêÎäî Í¥ÄÎ¶¨ÏûêÎßå ÌÜ†ÌÅ∞ÏùÑ ÏûêÏú†Î°≠Í≤å Ïù¥ÎèôÌï† Ïàò ÏûàÏäµÎãàÎã§. (Í¥ÄÎ¶¨Ïûê Ïù¥Îèô Í∂åÌïúÏù¥ Ìï¥Ï†úÎêòÏóàÏùÑ ÏàòÎèÑ ÏûàÏäµÎãàÎã§)", [{ text: "ÌôïÏù∏", class: "bg-red-600" }]);
            }
        }
    });

    const applyTheme = (theme) => {
        document.documentElement.classList.toggle('light', theme === 'light');
        // Re-render to ensure scrollbars update correctly on theme change (due to CSS variable change)
        render(); 
    }
    document.getElementById('theme-toggle-btn').addEventListener('click', () => {
        const newTheme = document.documentElement.classList.contains('light') ? 'dark' : 'light';
        localStorage.setItem('theme', newTheme);
        applyTheme(newTheme);
    });
    applyTheme(localStorage.getItem('theme') || 'dark');
</script>
</body>
</html>
